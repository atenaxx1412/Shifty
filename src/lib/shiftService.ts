import { 
  collection, 
  doc, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  getDocs, 
  getDoc,
  query, 
  where, 
  orderBy, 
  limit,
  onSnapshot,
  serverTimestamp,
  writeBatch,
  runTransaction
} from 'firebase/firestore';
import { db } from './firebase';
import { 
  ShiftExtended, 
  ShiftRequestEnhanced, 
  ShiftPattern,
  User,
  ConflictRecord,
  ModificationRecord
} from '@/types';
import { logDataChange, logSystem } from './auditLogger';

export class ShiftManagementService {
  private static instance: ShiftManagementService;
  private realtimeListeners = new Map<string, () => void>();

  private constructor() {}

  public static getInstance(): ShiftManagementService {
    if (!ShiftManagementService.instance) {
      ShiftManagementService.instance = new ShiftManagementService();
    }
    return ShiftManagementService.instance;
  }

  /**
   * スロットに未割り当てのスタッフを自動割り当て
   */
  private async autoAssignStaffToSlots(
    slots: any[],
    managerId: string,
    date: Date
  ): Promise<any[]> {
    console.log('🔄 Auto-assigning staff to slots...');

    // 利用可能なスタッフを取得
    const availableStaff = await this.getAvailableStaff(managerId, date);

    const processedSlots = await Promise.all(slots.map(async (slot) => {
      const currentAssigned = slot.assignedStaff?.length || 0;
      const requiredStaff = slot.requiredStaff || 0;

      // 既に十分なスタッフが割り当てられている場合はそのまま
      if (currentAssigned >= requiredStaff) {
        return slot;
      }

      // 必要な追加スタッフ数
      const neededStaff = requiredStaff - currentAssigned;

      // スキルマッチングを考慮して適切なスタッフを選択
      const suitableStaff = availableStaff
        .filter(staff => {
          // 既に割り当て済みでないことを確認
          if (slot.assignedStaff?.includes(staff.uid)) return false;

          // スキル要件チェック
          if (slot.requiredSkills?.length > 0) {
            const staffSkills = staff.skills || [];
            return slot.requiredSkills.some((skill: string) =>
              staffSkills.includes(skill)
            );
          }

          return true;
        })
        .slice(0, neededStaff);

      // 自動割り当て
      const newAssignedStaff = [
        ...(slot.assignedStaff || []),
        ...suitableStaff.map(staff => staff.uid)
      ];

      console.log(`📝 Slot ${slot.startTime}-${slot.endTime}: ${newAssignedStaff.length}/${requiredStaff} staff assigned`);

      return {
        ...slot,
        assignedStaff: newAssignedStaff
      };
    }));

    console.log('✅ Staff auto-assignment completed');
    return processedSlots;
  }

  /**
   * 利用可能なスタッフを取得
   */
  private async getAvailableStaff(managerId: string, date: Date): Promise<any[]> {
    try {
      // スタッフリストを取得
      const staffQuery = query(
        collection(db, 'users'),
        where('role', '==', 'staff'),
        where('managerId', '==', managerId),
        where('status', '==', 'active')
      );

      const staffSnapshot = await getDocs(staffQuery);
      const allStaff = staffSnapshot.docs.map(doc => ({
        uid: doc.id,
        ...doc.data()
      }));

      // 実際の実装では、ここで各スタッフの可用性をチェック
      // 簡易版として全てのアクティブスタッフを返す
      return allStaff;
    } catch (error) {
      console.error('❌ Error getting available staff:', error);
      return [];
    }
  }

  // ========== SHIFT CREATION & MANAGEMENT ==========

  /**
   * 新しいシフトを作成（拡張機能付き）
   */
  async createShift(
    shiftData: Partial<ShiftExtended>,
    createdBy: User
  ): Promise<ShiftExtended> {
    const now = new Date();
    const shiftId = `shift_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // スロットに未割り当てのスタッフがある場合は自動で割り当て
    const processedSlots = await this.autoAssignStaffToSlots(
      shiftData.slots || [],
      shiftData.managerId!,
      shiftData.date!
    );

    const newShift: ShiftExtended = {
      shiftId,
      managerId: shiftData.managerId!,
      date: shiftData.date!,
      slots: processedSlots,
      status: 'published',
      createdBy: createdBy.uid,
      createdAt: now,
      updatedAt: now,
      metadata: {
        totalRequiredStaff: this.calculateTotalRequiredStaff(processedSlots),
        totalAssignedStaff: this.calculateTotalAssignedStaff(processedSlots),
        estimatedCost: await this.estimateShiftCost(processedSlots, shiftData.managerId!),
        complexity: this.determineShiftComplexity(processedSlots),
        autogeneratedSlots: 0,
      },
      approvalWorkflow: {
        submittedBy: createdBy.uid,
        submittedAt: now,
        lastModifiedBy: createdBy.uid,
        modificationHistory: [{
          modifiedBy: createdBy.uid,
          modifiedAt: now,
          changes: { status: { before: null, after: 'published' } },
          reason: 'Initial creation (auto-approved)'
        }]
      },
      analytics: {
        lateChanges: 0,
        noShows: 0,
      },
      realTimeSync: {
        lastSyncAt: now,
        version: 1,
        conflicts: [],
      }
    };

    try {
      const docRef = await addDoc(collection(db, 'shifts_extended'), {
        ...newShift,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        'realTimeSync.lastSyncAt': serverTimestamp(),
        'approvalWorkflow.submittedAt': serverTimestamp(),
      });

      // ログ記録
      await logDataChange(
        'Shift Created',
        createdBy.uid,
        createdBy.name,
        createdBy.role,
        `shift:${shiftId}`,
        { 
          managerId: newShift.managerId,
          date: newShift.date.toISOString(),
          slotsCount: newShift.slots.length,
          complexity: newShift.metadata.complexity
        }
      );

      return { ...newShift, id: docRef.id };
    } catch (error) {
      console.error('Error creating shift:', error);
      throw new Error('Failed to create shift');
    }
  }

  /**
   * シフトを更新（競合検知・解決付き）
   */
  async updateShift(
    shiftId: string,
    updates: Partial<ShiftExtended>,
    updatedBy: User,
    reason?: string
  ): Promise<ShiftExtended> {
    return runTransaction(db, async (transaction) => {
      const shiftRef = doc(db, 'shifts_extended', shiftId);
      const shiftDoc = await transaction.get(shiftRef);

      if (!shiftDoc.exists()) {
        throw new Error('Shift not found');
      }

      const currentShift = { id: shiftDoc.id, ...shiftDoc.data() } as ShiftExtended;

      // 競合検知
      const conflicts = await this.detectConflicts(currentShift, updates, updatedBy);
      
      if (conflicts.length > 0) {
        // 自動解決可能な競合を処理
        const resolvedUpdates = await this.resolveConflicts(currentShift, updates, conflicts, updatedBy);
        updates = resolvedUpdates;
      }

      const now = new Date();
      const modificationRecord: ModificationRecord = {
        modifiedBy: updatedBy.uid,
        modifiedAt: now,
        changes: this.calculateChanges(currentShift, updates),
        reason: reason || 'Manual update'
      };

      const updatedShift: Partial<ShiftExtended> = {
        ...updates,
        updatedAt: now,
        'approvalWorkflow.lastModifiedBy': updatedBy.uid,
        'approvalWorkflow.modificationHistory': [
          ...currentShift.approvalWorkflow.modificationHistory,
          modificationRecord
        ],
        'realTimeSync.lastSyncAt': now,
        'realTimeSync.version': currentShift.realTimeSync.version + 1,
        'realTimeSync.conflicts': conflicts,
        'metadata.totalRequiredStaff': updates.slots ? 
          this.calculateTotalRequiredStaff(updates.slots) : 
          currentShift.metadata.totalRequiredStaff,
        'metadata.totalAssignedStaff': updates.slots ? 
          this.calculateTotalAssignedStaff(updates.slots) : 
          currentShift.metadata.totalAssignedStaff,
      };

      transaction.update(shiftRef, {
        ...updatedShift,
        updatedAt: serverTimestamp(),
        'realTimeSync.lastSyncAt': serverTimestamp(),
      });

      // ログ記録
      await logDataChange(
        'Shift Updated',
        updatedBy.uid,
        updatedBy.name,
        updatedBy.role,
        `shift:${shiftId}`,
        { 
          changes: modificationRecord.changes,
          reason: modificationRecord.reason,
          conflictsDetected: conflicts.length
        }
      );

      return { ...currentShift, ...updatedShift };
    });
  }

  /**
   * シフトの承認処理
   */
  async approveShift(
    shiftId: string,
    approvedBy: User,
    notes?: string
  ): Promise<ShiftExtended> {
    const shiftRef = doc(db, 'shifts_extended', shiftId);
    const now = new Date();

    const updates = {
      status: 'published' as const,
      'approvalWorkflow.approvedBy': approvedBy.uid,
      'approvalWorkflow.approvedAt': now,
      'approvalWorkflow.lastModifiedBy': approvedBy.uid,
      updatedAt: now,
      'realTimeSync.lastSyncAt': now,
    };

    await updateDoc(shiftRef, {
      ...updates,
      'approvalWorkflow.approvedAt': serverTimestamp(),
      updatedAt: serverTimestamp(),
      'realTimeSync.lastSyncAt': serverTimestamp(),
    });

    // 通知・ログ処理
    await this.notifyShiftApproval(shiftId, approvedBy, notes);
    
    await logDataChange(
      'Shift Approved',
      approvedBy.uid,
      approvedBy.name,
      approvedBy.role,
      `shift:${shiftId}`,
      { notes, timestamp: now.toISOString() }
    );

    // 更新されたシフトを取得
    const updatedDoc = await getDoc(shiftRef);
    return { id: updatedDoc.id, ...updatedDoc.data() } as ShiftExtended;
  }

  // ========== REAL-TIME SYNC ==========

  /**
   * リアルタイム同期の開始
   */
  subscribeToShiftUpdates(
    managerId: string, 
    callback: (shifts: ShiftExtended[]) => void
  ): () => void {
    // インデックスエラーを回避するため、より単純なクエリを使用
    const q = query(
      collection(db, 'shifts_extended'),
      where('managerId', '==', managerId),
      limit(50)
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const allShifts = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        // Firestoreのタイムスタンプを変換
        date: doc.data().date?.toDate() || new Date(),
        createdAt: doc.data().createdAt?.toDate() || new Date(),
        updatedAt: doc.data().updatedAt?.toDate() || new Date(),
      })) as ShiftExtended[];

      // フロントエンドでフィルタリングとソート
      const filteredShifts = allShifts
        .filter(shift => ['draft', 'published'].includes(shift.status))
        .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

      callback(filteredShifts);

      // メトリクス記録
      this.trackRealtimeMetrics(filteredShifts.length, !snapshot.metadata.fromCache);
    }, (error) => {
      console.error('❌ Error in shift subscription:', error);
      // エラー時は空の配列を返す
      callback([]);
    });

    this.realtimeListeners.set(`shifts:${managerId}`, unsubscribe);
    return unsubscribe;
  }

  /**
   * リアルタイム同期の停止
   */
  unsubscribeFromShiftUpdates(managerId: string): void {
    const unsubscribe = this.realtimeListeners.get(`shifts:${managerId}`);
    if (unsubscribe) {
      unsubscribe();
      this.realtimeListeners.delete(`shifts:${managerId}`);
    }
  }

  /**
   * シフトを削除
   */
  async deleteShift(shiftId: string, deletedBy: User): Promise<void> {
    const shiftRef = doc(db, 'shifts_extended', shiftId);
    
    try {
      const shiftDoc = await getDoc(shiftRef);
      if (!shiftDoc.exists()) {
        throw new Error('シフトが見つかりません');
      }

      const shiftData = shiftDoc.data() as ShiftExtended;
      
      // 削除可能（制限なし）

      // ログ記録
      await logDataChange({
        operation: 'DELETE',
        entityType: 'shift',
        entityId: shiftId,
        userId: deletedBy.uid,
        changes: { status: { before: shiftData.status, after: 'deleted' } },
        timestamp: new Date()
      });

      // Firestoreから削除
      await deleteDoc(shiftRef);
      
      console.log(`✅ Shift ${shiftId} deleted successfully by ${deletedBy.name}`);
      
    } catch (error) {
      console.error('❌ Error deleting shift:', error);
      throw error;
    }
  }

  // ========== HELPER METHODS ==========

  private calculateTotalRequiredStaff(slots: any[]): number {
    return slots.reduce((total, slot) => total + (slot.requiredStaff || 0), 0);
  }

  private calculateTotalAssignedStaff(slots: any[]): number {
    return slots.reduce((total, slot) => total + (slot.assignedStaff?.length || 0), 0);
  }

  private async estimateShiftCost(slots: any[], managerId: string): Promise<number> {
    // 基本的な時給計算（実際の実装では店舗固有のレートを使用）
    const baseHourlyRate = 1200; // 基本時給
    
    let totalCost = 0;
    for (const slot of slots) {
      const duration = this.calculateSlotDuration(slot.startTime, slot.endTime);
      const staffCount = slot.requiredStaff || 0;
      totalCost += (duration / 60) * staffCount * baseHourlyRate;
    }
    
    return Math.round(totalCost);
  }

  private calculateSlotDuration(startTime: string, endTime: string): number {
    const start = new Date(`2000-01-01T${startTime}`);
    const end = new Date(`2000-01-01T${endTime}`);
    return (end.getTime() - start.getTime()) / (1000 * 60); // minutes
  }

  private determineShiftComplexity(slots: any[]): 'simple' | 'moderate' | 'complex' {
    const totalSlots = slots.length;
    const totalStaff = this.calculateTotalRequiredStaff(slots);
    const hasSkillRequirements = slots.some(slot => slot.requiredSkills?.length > 0);

    if (totalSlots > 10 || totalStaff > 20 || hasSkillRequirements) {
      return 'complex';
    } else if (totalSlots > 5 || totalStaff > 10) {
      return 'moderate';
    } else {
      return 'simple';
    }
  }

  /**
   * 高度な競合検知システム - Phase 3.1対応
   */
  private async detectConflicts(
    currentShift: ShiftExtended, 
    updates: Partial<ShiftExtended>, 
    updatedBy: User
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];

    // バージョン競合チェック
    if (updates.realTimeSync && 
        currentShift.realTimeSync.version !== updates.realTimeSync.version) {
      conflicts.push({
        conflictId: `version_conflict_${Date.now()}`,
        type: 'concurrent_edit',
        description: 'Concurrent modification detected',
        affectedFields: ['version'],
      });
    }

    // スタッフ割り当て競合チェック
    if (updates.slots) {
      const staffConflicts = await this.detectStaffConflicts(currentShift, updates);
      conflicts.push(...staffConflicts);

      // 時間帯重複チェック
      const timeConflicts = await this.detectTimeConflicts(currentShift, updates);
      conflicts.push(...timeConflicts);

      // スキル要件競合チェック
      const skillConflicts = await this.detectSkillConflicts(currentShift, updates);
      conflicts.push(...skillConflicts);

      // 最小スタッフ数不足チェック
      const staffingConflicts = await this.detectStaffingConflicts(currentShift, updates);
      conflicts.push(...staffingConflicts);
    }

    return conflicts;
  }

  /**
   * スタッフ割り当て競合の検知
   */
  private async detectStaffConflicts(
    currentShift: ShiftExtended,
    updates: Partial<ShiftExtended>
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];
    
    if (!updates.slots) return conflicts;

    // 同じスタッフが複数スロットに割り当てられているかチェック
    const allAssignedStaff = updates.slots.flatMap(slot => slot.assignedStaff || []);
    const duplicateStaff = allAssignedStaff.filter((staff, index, arr) => 
      arr.indexOf(staff) !== index
    );

    if (duplicateStaff.length > 0) {
      conflicts.push({
        conflictId: `staff_duplicate_${Date.now()}`,
        type: 'data_mismatch',
        description: `Duplicate staff assignments detected: ${duplicateStaff.join(', ')}`,
        affectedFields: ['slots.assignedStaff'],
      });
    }

    // 他のシフトとの重複チェック（同じ時間帯）
    const conflictingShifts = await this.checkCrossShiftConflicts(
      currentShift.managerId,
      currentShift.date,
      updates.slots
    );

    conflicts.push(...conflictingShifts);

    return conflicts;
  }

  /**
   * 時間帯競合の検知
   */
  private async detectTimeConflicts(
    currentShift: ShiftExtended,
    updates: Partial<ShiftExtended>
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];
    
    if (!updates.slots) return conflicts;

    // スロット間の時間重複チェック
    for (let i = 0; i < updates.slots.length; i++) {
      for (let j = i + 1; j < updates.slots.length; j++) {
        const slot1 = updates.slots[i];
        const slot2 = updates.slots[j];
        
        if (this.isTimeOverlapping(slot1.startTime, slot1.endTime, slot2.startTime, slot2.endTime)) {
          // 同じスタッフが重複する時間帯に割り当てられているかチェック
          const commonStaff = (slot1.assignedStaff || []).filter(staff => 
            (slot2.assignedStaff || []).includes(staff)
          );
          
          if (commonStaff.length > 0) {
            conflicts.push({
              conflictId: `time_overlap_${Date.now()}_${i}_${j}`,
              type: 'data_mismatch',
              description: `Time overlap conflict: ${commonStaff.join(', ')} assigned to overlapping slots`,
              affectedFields: [`slots.${i}.assignedStaff`, `slots.${j}.assignedStaff`],
            });
          }
        }
      }
    }

    return conflicts;
  }

  /**
   * スキル要件競合の検知
   */
  private async detectSkillConflicts(
    currentShift: ShiftExtended,
    updates: Partial<ShiftExtended>
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];
    
    if (!updates.slots) return conflicts;

    for (const [slotIndex, slot] of updates.slots.entries()) {
      if (slot.requiredSkills && slot.assignedStaff) {
        for (const staffId of slot.assignedStaff) {
          // 実際の実装では、スタッフのスキル情報を取得して比較
          // ここではサンプル実装
          const staffSkills = await this.getStaffSkills(staffId);
          const missingSkills = slot.requiredSkills.filter(skill => 
            !staffSkills.includes(skill)
          );
          
          if (missingSkills.length > 0) {
            conflicts.push({
              conflictId: `skill_mismatch_${Date.now()}_${slotIndex}_${staffId}`,
              type: 'data_mismatch',
              description: `Staff ${staffId} lacks required skills: ${missingSkills.join(', ')}`,
              affectedFields: [`slots.${slotIndex}.assignedStaff`],
            });
          }
        }
      }
    }

    return conflicts;
  }

  /**
   * 最小スタッフ数競合の検知
   */
  private async detectStaffingConflicts(
    currentShift: ShiftExtended,
    updates: Partial<ShiftExtended>
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];
    
    if (!updates.slots) return conflicts;

    for (const [slotIndex, slot] of updates.slots.entries()) {
      const assignedCount = slot.assignedStaff?.length || 0;
      const requiredCount = slot.requiredStaff || 0;
      
      if (assignedCount < requiredCount) {
        conflicts.push({
          conflictId: `understaffed_${Date.now()}_${slotIndex}`,
          type: 'data_mismatch',
          description: `Slot understaffed: ${assignedCount}/${requiredCount} staff assigned`,
          affectedFields: [`slots.${slotIndex}.assignedStaff`],
        });
      } else if (assignedCount > requiredCount * 1.2) { // 20%超過で警告
        conflicts.push({
          conflictId: `overstaffed_${Date.now()}_${slotIndex}`,
          type: 'data_mismatch',
          description: `Slot overstaffed: ${assignedCount}/${requiredCount} staff assigned`,
          affectedFields: [`slots.${slotIndex}.assignedStaff`],
        });
      }
    }

    return conflicts;
  }

  /**
   * 他のシフトとの競合チェック
   */
  private async checkCrossShiftConflicts(
    managerId: string,
    date: Date,
    slots: any[]
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];

    // 同じ日の他のシフトを取得
    const existingShifts = await this.getShiftsByShop(managerId, date, date);
    
    for (const existingShift of existingShifts) {
      for (const newSlot of slots) {
        for (const existingSlot of existingShift.slots) {
          // 時間重複チェック
          if (this.isTimeOverlapping(
            newSlot.startTime, newSlot.endTime,
            existingSlot.startTime, existingSlot.endTime
          )) {
            // 同じスタッフが割り当てられているかチェック
            const commonStaff = (newSlot.assignedStaff || []).filter(staff => 
              (existingSlot.assignedStaff || []).includes(staff)
            );
            
            if (commonStaff.length > 0) {
              conflicts.push({
                conflictId: `cross_shift_conflict_${Date.now()}_${existingShift.shiftId}`,
                type: 'data_mismatch',
                description: `Staff ${commonStaff.join(', ')} assigned to overlapping shifts`,
                affectedFields: ['slots.assignedStaff'],
              });
            }
          }
        }
      }
    }

    return conflicts;
  }

  /**
   * スタッフのスキル情報を取得
   */
  private async getStaffSkills(staffId: string): Promise<string[]> {
    // 実際の実装では、ユーザー情報からスキルを取得
    // ここではサンプル実装
    const sampleSkills: Record<string, string[]> = {
      'staff1': ['レジ', '接客', '商品知識'],
      'staff2': ['キッチン', '調理', '衛生管理'],
      'staff3': ['フロア', '清掃', '商品陳列'],
    };
    
    return sampleSkills[staffId] || [];
  }

  /**
   * 時間重複判定
   */
  private isTimeOverlapping(
    start1: string,
    end1: string,
    start2: string,
    end2: string
  ): boolean {
    const start1Time = new Date(`2000-01-01T${start1}`);
    const end1Time = new Date(`2000-01-01T${end1}`);
    const start2Time = new Date(`2000-01-01T${start2}`);
    const end2Time = new Date(`2000-01-01T${end2}`);
    
    return (start1Time < end2Time) && (start2Time < end1Time);
  }

  /**
   * 高度な競合解決システム - Phase 3.1対応
   */
  private async resolveConflicts(
    currentShift: ShiftExtended,
    updates: Partial<ShiftExtended>,
    conflicts: ConflictRecord[],
    updatedBy: User
  ): Promise<Partial<ShiftExtended>> {
    let resolvedUpdates = { ...updates };

    for (const conflict of conflicts) {
      switch (conflict.type) {
        case 'concurrent_edit':
          resolvedUpdates = await this.resolveConcurrentEdit(conflict, resolvedUpdates, updatedBy);
          break;
        
        case 'data_mismatch':
          resolvedUpdates = await this.resolveDataMismatch(conflict, resolvedUpdates, currentShift, updatedBy);
          break;
        
        default:
          // 解決不可能な競合は手動対応が必要
          conflict.resolutionMethod = 'manual';
      }
    }

    return resolvedUpdates;
  }

  /**
   * 同時編集競合の解決
   */
  private async resolveConcurrentEdit(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    updatedBy: User
  ): Promise<Partial<ShiftExtended>> {
    // Root権限者は常に優先
    if (updatedBy.role === 'root') {
      conflict.resolvedAt = new Date();
      conflict.resolvedBy = updatedBy.uid;
      conflict.resolutionMethod = 'automatic';
      return updates;
    }

    // Manager権限者は通常優先（ただし他のManagerとの競合時は時間順）
    if (updatedBy.role === 'manager') {
      conflict.resolvedAt = new Date();
      conflict.resolvedBy = updatedBy.uid;
      conflict.resolutionMethod = 'automatic';
      return updates;
    }

    // Staff権限者は手動解決が必要
    conflict.resolutionMethod = 'manual';
    return updates;
  }

  /**
   * データ不整合競合の解決
   */
  private async resolveDataMismatch(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    currentShift: ShiftExtended,
    updatedBy: User
  ): Promise<Partial<ShiftExtended>> {
    if (conflict.conflictId.includes('understaffed')) {
      // スタッフ不足の場合、利用可能なスタッフを自動提案
      return await this.resolveUnderstaffing(conflict, updates, currentShift);
    }
    
    if (conflict.conflictId.includes('overstaffed')) {
      // スタッフ過多の場合、適切なスタッフ数に調整
      return await this.resolveOverstaffing(conflict, updates, currentShift);
    }
    
    if (conflict.conflictId.includes('skill_mismatch')) {
      // スキル不一致の場合、代替スタッフを提案
      return await this.resolveSkillMismatch(conflict, updates, currentShift);
    }
    
    if (conflict.conflictId.includes('duplicate') || conflict.conflictId.includes('overlap')) {
      // 重複割り当ての場合、優先度に基づいて調整
      return await this.resolveDuplicateAssignment(conflict, updates, currentShift);
    }

    // 自動解決不可能な場合
    conflict.resolutionMethod = 'escalated';
    return updates;
  }

  /**
   * スタッフ不足問題の解決
   */
  private async resolveUnderstaffing(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    currentShift: ShiftExtended
  ): Promise<Partial<ShiftExtended>> {
    if (!updates.slots) return updates;

    // 影響を受けるスロットのインデックスを抽出
    const slotIndex = this.extractSlotIndex(conflict.affectedFields[0]);
    if (slotIndex === -1) return updates;

    const slot = updates.slots[slotIndex];
    const requiredStaff = slot.requiredStaff || 0;
    const currentStaff = slot.assignedStaff?.length || 0;
    const neededStaff = requiredStaff - currentStaff;

    // 利用可能なスタッフを検索
    const availableStaff = await this.findAvailableStaff(
      currentShift.managerId,
      currentShift.date,
      slot.startTime,
      slot.endTime,
      slot.requiredSkills || []
    );

    if (availableStaff.length >= neededStaff) {
      // 自動的にスタッフを割り当て
      const staffToAssign = availableStaff.slice(0, neededStaff);
      updates.slots[slotIndex] = {
        ...slot,
        assignedStaff: [...(slot.assignedStaff || []), ...staffToAssign.map(s => s.uid)]
      };
      
      conflict.resolvedAt = new Date();
      conflict.resolutionMethod = 'automatic';
      conflict.description += ` - Auto-assigned: ${staffToAssign.map(s => s.name).join(', ')}`;
    } else {
      // 部分的な解決
      if (availableStaff.length > 0) {
        updates.slots[slotIndex] = {
          ...slot,
          assignedStaff: [...(slot.assignedStaff || []), ...availableStaff.map(s => s.uid)]
        };
        conflict.resolutionMethod = 'manual';
        conflict.description += ` - Partially resolved: ${availableStaff.length}/${neededStaff} staff assigned`;
      } else {
        conflict.resolutionMethod = 'escalated';
      }
    }

    return updates;
  }

  /**
   * スタッフ過多問題の解決
   */
  private async resolveOverstaffing(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    currentShift: ShiftExtended
  ): Promise<Partial<ShiftExtended>> {
    if (!updates.slots) return updates;

    const slotIndex = this.extractSlotIndex(conflict.affectedFields[0]);
    if (slotIndex === -1) return updates;

    const slot = updates.slots[slotIndex];
    const requiredStaff = slot.requiredStaff || 0;
    const currentStaff = slot.assignedStaff || [];
    
    if (currentStaff.length > requiredStaff) {
      // 優先度に基づいてスタッフを削減（経験、過去の評価などに基づく）
      const staffToKeep = await this.selectOptimalStaff(
        currentStaff, 
        requiredStaff, 
        slot.requiredSkills || []
      );
      
      updates.slots[slotIndex] = {
        ...slot,
        assignedStaff: staffToKeep
      };
      
      conflict.resolvedAt = new Date();
      conflict.resolutionMethod = 'automatic';
    }

    return updates;
  }

  /**
   * スキル不一致問題の解決
   */
  private async resolveSkillMismatch(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    currentShift: ShiftExtended
  ): Promise<Partial<ShiftExtended>> {
    if (!updates.slots) return updates;

    const slotIndex = this.extractSlotIndex(conflict.affectedFields[0]);
    if (slotIndex === -1) return updates;

    const slot = updates.slots[slotIndex];
    
    // スキル要件を満たすスタッフを検索
    const qualifiedStaff = await this.findQualifiedStaff(
      currentShift.managerId,
      currentShift.date,
      slot.startTime,
      slot.endTime,
      slot.requiredSkills || []
    );

    if (qualifiedStaff.length >= (slot.requiredStaff || 0)) {
      // 適格なスタッフに置き換え
      const selectedStaff = qualifiedStaff.slice(0, slot.requiredStaff || 0);
      updates.slots[slotIndex] = {
        ...slot,
        assignedStaff: selectedStaff.map(s => s.uid)
      };
      
      conflict.resolvedAt = new Date();
      conflict.resolutionMethod = 'automatic';
    } else {
      conflict.resolutionMethod = 'manual';
    }

    return updates;
  }

  /**
   * 重複割り当て問題の解決
   */
  private async resolveDuplicateAssignment(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    currentShift: ShiftExtended
  ): Promise<Partial<ShiftExtended>> {
    if (!updates.slots) return updates;

    // 重複しているスタッフを特定
    const duplicateStaffIds = this.extractDuplicateStaff(conflict.description);
    
    for (const staffId of duplicateStaffIds) {
      // 最も重要なスロット（優先度が高い）に割り当て、他から削除
      const slotsWithStaff = updates.slots
        .map((slot, index) => ({ slot, index }))
        .filter(({ slot }) => slot.assignedStaff?.includes(staffId));
      
      if (slotsWithStaff.length > 1) {
        // 優先度が最も高いスロットを保持
        const highestPrioritySlot = slotsWithStaff.reduce((prev, current) => 
          this.getSlotPriority(current.slot) > this.getSlotPriority(prev.slot) ? current : prev
        );
        
        // 他のスロットから削除
        slotsWithStaff.forEach(({ slot, index }) => {
          if (index !== highestPrioritySlot.index) {
            updates.slots![index] = {
              ...slot,
              assignedStaff: slot.assignedStaff?.filter(id => id !== staffId) || []
            };
          }
        });
      }
    }

    conflict.resolvedAt = new Date();
    conflict.resolutionMethod = 'automatic';
    return updates;
  }

  /**
   * 利用可能なスタッフを検索
   */
  private async findAvailableStaff(
    managerId: string,
    date: Date,
    startTime: string,
    endTime: string,
    requiredSkills: string[]
  ): Promise<User[]> {
    // 実際の実装では、データベースからスタッフを検索
    // ここではサンプル実装
    const sampleStaff: User[] = [
      {
        uid: 'staff4',
        email: 'staff4@example.com',
        name: '鈴木一郎',
        role: 'staff',
        managerId,
        skills: ['レジ', '接客'],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        uid: 'staff5',
        email: 'staff5@example.com',
        name: '田中花子',
        role: 'staff',
        managerId,
        skills: ['フロア', '清掃'],
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];

    // スキル要件と時間可用性をチェック
    return sampleStaff.filter(staff => 
      this.hasRequiredSkills(staff.skills || [], requiredSkills) &&
      this.isStaffAvailable(staff.uid, date, startTime, endTime)
    );
  }

  /**
   * 適格なスタッフを検索
   */
  private async findQualifiedStaff(
    managerId: string,
    date: Date,
    startTime: string,
    endTime: string,
    requiredSkills: string[]
  ): Promise<User[]> {
    const availableStaff = await this.findAvailableStaff(managerId, date, startTime, endTime, requiredSkills);
    return availableStaff.filter(staff => 
      this.hasRequiredSkills(staff.skills || [], requiredSkills)
    );
  }

  /**
   * 最適なスタッフを選択
   */
  private async selectOptimalStaff(
    staffIds: string[],
    requiredCount: number,
    requiredSkills: string[]
  ): Promise<string[]> {
    // 実際の実装では、スタッフの評価、経験、スキルマッチング等を考慮
    // ここではサンプル実装（スキル保有数でソート）
    const staffWithSkills = await Promise.all(
      staffIds.map(async id => {
        const skills = await this.getStaffSkills(id);
        const skillMatch = skills.filter(skill => requiredSkills.includes(skill)).length;
        return { id, skillMatch };
      })
    );

    return staffWithSkills
      .sort((a, b) => b.skillMatch - a.skillMatch)
      .slice(0, requiredCount)
      .map(s => s.id);
  }

  /**
   * ユーティリティメソッド群
   */
  private extractSlotIndex(affectedField: string): number {
    const match = affectedField.match(/slots\.(\d+)/);
    return match ? parseInt(match[1]) : -1;
  }

  private extractDuplicateStaff(description: string): string[] {
    const match = description.match(/: (.+?)(?:\s|$)/);
    return match ? match[1].split(', ') : [];
  }

  private getSlotPriority(slot: any): number {
    const priorityMap = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };
    return priorityMap[slot.priority as keyof typeof priorityMap] || 1;
  }

  private hasRequiredSkills(staffSkills: string[], requiredSkills: string[]): boolean {
    return requiredSkills.every(skill => staffSkills.includes(skill));
  }

  private async isStaffAvailable(staffId: string, date: Date, startTime: string, endTime: string): Promise<boolean> {
    // 実際の実装では、スタッフの可用性をチェック
    // ここではサンプル実装
    return true;
  }

  private calculateChanges(current: ShiftExtended, updates: Partial<ShiftExtended>): Record<string, { before: any; after: any }> {
    const changes: Record<string, { before: any; after: any }> = {};

    Object.keys(updates).forEach(key => {
      const beforeValue = (current as any)[key];
      const afterValue = (updates as any)[key];
      
      if (JSON.stringify(beforeValue) !== JSON.stringify(afterValue)) {
        changes[key] = { before: beforeValue, after: afterValue };
      }
    });

    return changes;
  }

  private async notifyShiftApproval(shiftId: string, approvedBy: User, notes?: string): Promise<void> {
    // 実装: スタッフへの通知送信
    console.log(`🔔 Shift ${shiftId} approved by ${approvedBy.name}`);
  }

  private trackRealtimeMetrics(shiftCount: number, fromServer: boolean): void {
    // 実装: リアルタイム同期のメトリクス記録
    console.log(`📊 Realtime sync: ${shiftCount} shifts, from server: ${fromServer}`);
  }

  // ========== SHIFT GENERATION ENGINE - Phase 3.1 ==========

  /**
   * 自動シフト生成エンジン - AI最適化対応
   */
  async generateOptimalShift(
    managerId: string,
    date: Date,
    requirements: ShiftGenerationRequirements,
    generatedBy: User
  ): Promise<ShiftExtended> {
    console.log(`🔄 Starting shift generation for ${managerId} on ${date.toISOString()}`);
    
    // Step 1: 基本制約の収集
    const constraints = await this.collectShiftConstraints(managerId, date, requirements);
    
    // Step 2: スタッフ可用性の分析
    const staffAvailability = await this.analyzeStaffAvailability(managerId, date);
    
    // Step 3: 最適化アルゴリズムの実行
    const optimizedSlots = await this.runOptimizationEngine(constraints, staffAvailability, requirements);
    
    // Step 4: シフトの構築
    const generatedShift = await this.constructOptimalShift(
      managerId, 
      date, 
      optimizedSlots, 
      requirements, 
      generatedBy
    );
    
    // Step 5: 品質検証
    const qualityScore = await this.validateShiftQuality(generatedShift);
    
    // Step 6: 保存とログ
    const savedShift = await this.saveGeneratedShift(generatedShift, qualityScore, generatedBy);
    
    console.log(`✅ Shift generation completed with quality score: ${qualityScore}`);
    return savedShift;
  }

  /**
   * 制約条件の収集
   */
  private async collectShiftConstraints(
    managerId: string, 
    date: Date, 
    requirements: ShiftGenerationRequirements
  ): Promise<ShiftConstraints> {
    const constraints: ShiftConstraints = {
      businessHours: requirements.businessHours || { start: '09:00', end: '21:00' },
      minimumStaffPerSlot: requirements.minimumStaffPerSlot || 2,
      maximumStaffPerSlot: requirements.maximumStaffPerSlot || 6,
      requiredSkills: requirements.requiredSkills || [],
      budgetLimit: requirements.budgetLimit,
      specialRequirements: requirements.specialRequirements || [],
      
      // 曜日別制約
      dayOfWeekConstraints: this.getDayOfWeekConstraints(date),
      
      // 法的制約（労働基準法等）
      legalConstraints: {
        maxConsecutiveHours: 8,
        minBreakTime: 60,
        maxWeeklyHours: 40
      },
      
      // 過去のパフォーマンスデータ
      historicalData: await this.getHistoricalShiftData(managerId, date)
    };

    return constraints;
  }

  /**
   * スタッフ可用性の分析
   */
  private async analyzeStaffAvailability(
    managerId: string, 
    date: Date
  ): Promise<StaffAvailabilityMatrix> {
    // スタッフの希望シフトを取得
    const shiftRequests = await this.getShiftRequestsForDate(managerId, date);
    
    // スタッフのスキルと経験レベルを取得
    const staffProfiles = await this.getStaffProfiles(managerId);
    
    // 既存のシフト割り当てをチェック
    const existingAssignments = await this.getExistingAssignments(managerId, date);
    
    // 可用性マトリックスを構築
    const availabilityMatrix: StaffAvailabilityMatrix = {
      date,
      staffAvailability: new Map(),
      skillMatrix: new Map(),
      preferenceScores: new Map(),
      conflictIndicators: new Map()
    };

    for (const staff of staffProfiles) {
      // 基本的な可用性
      const availability = this.calculateStaffAvailability(staff, shiftRequests, existingAssignments);
      availabilityMatrix.staffAvailability.set(staff.uid, availability);
      
      // スキルマッピング
      availabilityMatrix.skillMatrix.set(staff.uid, staff.skills || []);
      
      // 希望度スコア
      const preferenceScore = this.calculatePreferenceScore(staff.uid, shiftRequests);
      availabilityMatrix.preferenceScores.set(staff.uid, preferenceScore);
      
      // 競合指標
      const conflicts = await this.detectStaffConflicts(staff.uid, date, existingAssignments);
      availabilityMatrix.conflictIndicators.set(staff.uid, conflicts.length);
    }

    return availabilityMatrix;
  }

  /**
   * 最適化エンジンの実行
   */
  private async runOptimizationEngine(
    constraints: ShiftConstraints,
    availability: StaffAvailabilityMatrix,
    requirements: ShiftGenerationRequirements
  ): Promise<OptimizedSlot[]> {
    console.log('🧠 Running AI optimization engine...');
    
    // Step 1: 時間スロットの生成
    const timeSlots = this.generateTimeSlots(constraints.businessHours, requirements.slotDuration || 120);
    
    // Step 2: 各スロットに対する最適化
    const optimizedSlots: OptimizedSlot[] = [];
    
    for (const timeSlot of timeSlots) {
      const optimizedSlot = await this.optimizeSlot(
        timeSlot, 
        constraints, 
        availability, 
        requirements
      );
      optimizedSlots.push(optimizedSlot);
    }
    
    // Step 3: 全体最適化（スロット間の調整）
    const globallyOptimized = await this.performGlobalOptimization(optimizedSlots, constraints);
    
    // Step 4: 品質向上のための調整
    const finalOptimized = await this.applyQualityEnhancements(globallyOptimized, availability);
    
    console.log(`✅ Optimization completed: ${finalOptimized.length} slots generated`);
    return finalOptimized;
  }

  /**
   * 個別スロットの最適化
   */
  private async optimizeSlot(
    timeSlot: TimeSlotTemplate,
    constraints: ShiftConstraints,
    availability: StaffAvailabilityMatrix,
    requirements: ShiftGenerationRequirements
  ): Promise<OptimizedSlot> {
    const candidateStaff = this.findCandidateStaff(timeSlot, availability, constraints);
    
    // AI スコアリング
    const scoredCandidates = candidateStaff.map(staff => ({
      staffId: staff.uid,
      staff,
      scores: {
        skillMatch: this.calculateSkillMatchScore(staff.skills || [], timeSlot.requiredSkills),
        availability: availability.preferenceScores.get(staff.uid) || 0,
        experience: this.calculateExperienceScore(staff),
        workload: this.calculateWorkloadScore(staff.uid, availability.date),
        cost: this.calculateCostScore(staff),
        fairness: this.calculateFairnessScore(staff.uid, availability.date)
      }
    }));
    
    // 重み付きスコアで最終選択
    const selectedStaff = this.selectOptimalStaffForSlot(
      scoredCandidates, 
      timeSlot.requiredStaff,
      requirements.optimizationStrategy || 'balanced'
    );
    
    return {
      slotId: `slot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      startTime: timeSlot.startTime,
      endTime: timeSlot.endTime,
      requiredStaff: timeSlot.requiredStaff,
      assignedStaff: selectedStaff.map(s => s.staffId),
      requiredSkills: timeSlot.requiredSkills,
      priority: timeSlot.priority,
      estimatedDuration: this.calculateDuration(timeSlot.startTime, timeSlot.endTime),
      optimizationMetrics: {
        totalScore: selectedStaff.reduce((sum, s) => sum + this.calculateTotalScore(s.scores), 0),
        skillCoverage: this.calculateSkillCoverage(selectedStaff, timeSlot.requiredSkills),
        costEfficiency: this.calculateCostEfficiency(selectedStaff),
        staffSatisfaction: this.calculateStaffSatisfaction(selectedStaff, availability)
      }
    };
  }

  /**
   * グローバル最適化
   */
  private async performGlobalOptimization(
    slots: OptimizedSlot[],
    constraints: ShiftConstraints
  ): Promise<OptimizedSlot[]> {
    console.log('🔄 Performing global optimization...');
    
    // 重複割り当ての解決
    const deduplicatedSlots = this.resolveDuplicateAssignments(slots);
    
    // 労働時間の均等化
    const balancedSlots = this.balanceWorkload(deduplicatedSlots, constraints);
    
    // コスト最適化
    const costOptimizedSlots = this.optimizeCosts(balancedSlots, constraints);
    
    // 最終品質チェック
    const qualityCheckedSlots = this.performQualityCheck(costOptimizedSlots, constraints);
    
    return qualityCheckedSlots;
  }

  /**
   * シフトの構築
   */
  private async constructOptimalShift(
    managerId: string,
    date: Date,
    optimizedSlots: OptimizedSlot[],
    requirements: ShiftGenerationRequirements,
    generatedBy: User
  ): Promise<ShiftExtended> {
    const shiftId = `shift_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date();

    // スロットをShiftSlot形式に変換
    const shiftSlots: ShiftSlot[] = optimizedSlots.map(slot => ({
      slotId: slot.slotId,
      startTime: slot.startTime,
      endTime: slot.endTime,
      requiredStaff: slot.requiredStaff,
      assignedStaff: slot.assignedStaff,
      requiredSkills: slot.requiredSkills,
      priority: slot.priority,
      estimatedDuration: slot.estimatedDuration
    }));

    const generatedShift: ShiftExtended = {
      shiftId,
      managerId,
      date,
      slots: shiftSlots,
      status: 'published', // 自動生成されたシフトは即座に有効
      createdBy: generatedBy.uid,
      createdAt: now,
      updatedAt: now,
      
      metadata: {
        totalRequiredStaff: this.calculateTotalRequiredStaff(shiftSlots),
        totalAssignedStaff: this.calculateTotalAssignedStaff(shiftSlots),
        estimatedCost: await this.estimateShiftCost(shiftSlots, managerId),
        complexity: this.determineShiftComplexity(shiftSlots),
        autogeneratedSlots: shiftSlots.length,
      },
      
      approvalWorkflow: {
        submittedBy: generatedBy.uid,
        submittedAt: now,
        lastModifiedBy: generatedBy.uid,
        modificationHistory: [{
          modifiedBy: generatedBy.uid,
          modifiedAt: now,
          changes: { status: { before: null, after: 'draft' } },
          reason: 'Auto-generated by optimization engine'
        }]
      },
      
      analytics: {
        lateChanges: 0,
        noShows: 0,
      },
      
      realTimeSync: {
        lastSyncAt: now,
        version: 1,
        conflicts: [],
      },
      
      // 生成エンジン固有のメタデータ
      generationMetrics: {
        algorithmVersion: '3.1.0',
        optimizationStrategy: requirements.optimizationStrategy || 'balanced',
        totalOptimizationTime: 0, // 実際の処理時間で更新
        qualityScore: 0, // 後で計算
        aiRecommendations: optimizedSlots.map(slot => ({
          slotId: slot.slotId,
          confidence: slot.optimizationMetrics.totalScore / 100,
          alternatives: [] // 代替案があれば追加
        }))
      }
    };

    return generatedShift;
  }

  /**
   * 品質検証
   */
  private async validateShiftQuality(shift: ShiftExtended): Promise<number> {
    let qualityScore = 0;
    let maxScore = 0;

    // スタッフィングの適切性 (25点)
    const staffingScore = this.evaluateStaffingQuality(shift.slots);
    qualityScore += staffingScore;
    maxScore += 25;

    // スキルマッチング (20点)
    const skillScore = await this.evaluateSkillMatching(shift.slots);
    qualityScore += skillScore;
    maxScore += 20;

    // コスト効率性 (20点)
    const costScore = this.evaluateCostEfficiency(shift.metadata.estimatedCost, shift.slots.length);
    qualityScore += costScore;
    maxScore += 20;

    // 公平性 (15点)
    const fairnessScore = await this.evaluateFairness(shift);
    qualityScore += fairnessScore;
    maxScore += 15;

    // 制約遵守 (20点)
    const constraintScore = this.evaluateConstraintCompliance(shift);
    qualityScore += constraintScore;
    maxScore += 20;

    return Math.round((qualityScore / maxScore) * 100);
  }

  /**
   * 生成されたシフトの保存
   */
  private async saveGeneratedShift(
    shift: ShiftExtended, 
    qualityScore: number, 
    generatedBy: User
  ): Promise<ShiftExtended> {
    // 品質スコアを追加
    if (shift.generationMetrics) {
      shift.generationMetrics.qualityScore = qualityScore;
    }

    try {
      const docRef = await addDoc(collection(db, 'shifts_extended'), {
        ...shift,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        'realTimeSync.lastSyncAt': serverTimestamp(),
        'approvalWorkflow.submittedAt': serverTimestamp(),
      });

      // 生成ログ記録
      await logSystem(
        'Auto Shift Generated',
        generatedBy.uid,
        generatedBy.name,
        generatedBy.role,
        {
          shiftId: shift.shiftId,
          managerId: shift.managerId,
          date: shift.date.toISOString(),
          slotsGenerated: shift.slots.length,
          qualityScore,
          algorithm: shift.generationMetrics?.algorithmVersion || 'unknown'
        }
      );

      return { ...shift, id: docRef.id };
    } catch (error) {
      console.error('Error saving generated shift:', error);
      throw new Error('Failed to save generated shift');
    }
  }

  /**
   * ヘルパーメソッド群
   */
  private generateTimeSlots(businessHours: { start: string; end: string }, duration: number): TimeSlotTemplate[] {
    // 実装: ビジネス時間を指定された間隔で分割
    const slots: TimeSlotTemplate[] = [];
    const startHour = parseInt(businessHours.start.split(':')[0]);
    const endHour = parseInt(businessHours.end.split(':')[0]);
    const slotDurationHours = duration / 60;
    
    for (let hour = startHour; hour < endHour; hour += slotDurationHours) {
      const nextHour = Math.min(hour + slotDurationHours, endHour);
      slots.push({
        startTime: `${hour.toString().padStart(2, '0')}:00`,
        endTime: `${nextHour.toString().padStart(2, '0')}:00`,
        requiredStaff: 2, // デフォルト値
        requiredSkills: [],
        priority: 'medium'
      });
    }
    
    return slots;
  }

  private calculateDuration(startTime: string, endTime: string): number {
    return this.calculateSlotDuration(startTime, endTime);
  }

  // その他のヘルパーメソッド（簡略化のため一部のみ実装）
  private getDayOfWeekConstraints(date: Date): any {
    return { type: 'standard', multiplier: 1 };
  }

  private async getHistoricalShiftData(managerId: string, date: Date): Promise<any> {
    return { averageStaff: 3, peakHours: ['12:00-14:00', '18:00-20:00'] };
  }

  private calculateTotalScore(scores: any): number {
    return Object.values(scores).reduce((sum: number, score) => sum + (score as number), 0) / Object.keys(scores).length;
  }

  // 追加のインターフェース定義が必要（types/index.ts に追加予定）

  // ========== PUBLIC QUERY METHODS ==========

  /**
   * 店舗のシフト一覧を取得
   */
  async getShiftsByShop(managerId: string, startDate?: Date, endDate?: Date): Promise<ShiftExtended[]> {
    // インデックスエラーを回避するため、managerIdのみでクエリ
    const q = query(
      collection(db, 'shifts_extended'),
      where('managerId', '==', managerId)
    );

    const snapshot = await getDocs(q);
    const allShifts = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      date: doc.data().date?.toDate() || new Date(),
      createdAt: doc.data().createdAt?.toDate() || new Date(),
      updatedAt: doc.data().updatedAt?.toDate() || new Date(),
    })) as ShiftExtended[];

    // フロントエンドで日付フィルタリングとソート
    let filteredShifts = allShifts;
    
    if (startDate) {
      filteredShifts = filteredShifts.filter(shift => new Date(shift.date) >= startDate);
    }
    if (endDate) {
      filteredShifts = filteredShifts.filter(shift => new Date(shift.date) <= endDate);
    }

    // 日付でソート
    return filteredShifts.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
  }

  /**
   * ユーザーのシフトリクエスト一覧を取得
   */
  async getShiftRequestsByUser(userId: string): Promise<ShiftRequestEnhanced[]> {
    const q = query(
      collection(db, 'shift_requests_enhanced'),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc')
    );

    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      date: doc.data().date?.toDate() || new Date(),
      createdAt: doc.data().createdAt?.toDate() || new Date(),
      updatedAt: doc.data().updatedAt?.toDate() || new Date(),
    })) as ShiftRequestEnhanced[];
  }

  // ========== STAFF SPECIFIC METHODS ==========

  /**
   * スタッフ用: 自分のシフトをリアルタイムで取得
   */
  subscribeToStaffShifts(
    staffId: string,
    callback: (shifts: ShiftExtended[]) => void
  ): () => void {
    console.log('🔄 Setting up staff shift subscription for:', staffId);

    // スタッフは発行済み（published）シフトのみ表示
    const q = query(
      collection(db, 'shifts_extended'),
      where('status', '==', 'published'),
      limit(100)
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      try {
        const allShifts = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          date: doc.data().date?.toDate() || new Date(),
          createdAt: doc.data().createdAt?.toDate() || new Date(),
          updatedAt: doc.data().updatedAt?.toDate() || new Date(),
        })) as ShiftExtended[];

        // スタッフに割り当てられたシフトのみフィルタリング
        const staffShifts = allShifts.filter(shift => {
          if (!shift.slots || shift.slots.length === 0) return false;

          return shift.slots.some(slot =>
            slot.assignedStaff &&
            slot.assignedStaff.includes(staffId)
          );
        });

        console.log(`📊 Found ${staffShifts.length} shifts for staff ${staffId}`);
        callback(staffShifts.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()));
      } catch (error) {
        console.error('❌ Error processing staff shifts:', error);
        callback([]);
      }
    }, (error) => {
      console.error('❌ Staff shift subscription error:', error);
      callback([]);
    });

    return unsubscribe;
  }

  /**
   * スタッフ用: 指定期間のシフトを取得
   */
  async getStaffShiftsForPeriod(
    staffId: string,
    startDate: Date,
    endDate: Date
  ): Promise<ShiftExtended[]> {
    try {
      console.log(`📅 Getting staff shifts for ${staffId} from ${startDate.toISOString()} to ${endDate.toISOString()}`);

      // 期間内の発行済みシフトを取得
      const q = query(
        collection(db, 'shifts_extended'),
        where('status', '==', 'published')
      );

      const snapshot = await getDocs(q);
      const allShifts = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        date: doc.data().date?.toDate() || new Date(),
        createdAt: doc.data().createdAt?.toDate() || new Date(),
        updatedAt: doc.data().updatedAt?.toDate() || new Date(),
      })) as ShiftExtended[];

      // 期間とスタッフでフィルタリング
      const staffShifts = allShifts.filter(shift => {
        const shiftDate = new Date(shift.date);
        const inPeriod = shiftDate >= startDate && shiftDate <= endDate;
        const assignedToStaff = shift.slots?.some(slot =>
          slot.assignedStaff && slot.assignedStaff.includes(staffId)
        );

        return inPeriod && assignedToStaff;
      });

      return staffShifts.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    } catch (error) {
      console.error('❌ Error fetching staff shifts for period:', error);
      return [];
    }
  }

  /**
   * シフトを一括発行（draft → published）
   */
  async publishShifts(shiftIds: string[]): Promise<void> {
    try {
      console.log(`📤 Publishing ${shiftIds.length} shifts...`);

      // 各シフトのstatusをpublishedに更新
      const updatePromises = shiftIds.map(async (shiftId) => {
        const shiftRef = doc(db, 'shifts_extended', shiftId);
        await updateDoc(shiftRef, {
          status: 'published',
          updatedAt: serverTimestamp(),
          publishedAt: serverTimestamp(),
          'auditLog': {
            lastAction: 'published',
            performedBy: 'manager',
            timestamp: serverTimestamp(),
            changes: { status: { before: 'draft', after: 'published' } },
            reason: 'Manager published shift'
          }
        });
        console.log(`✅ Published shift: ${shiftId}`);
      });

      // 全てのシフトを並行更新
      await Promise.all(updatePromises);

      console.log(`🎉 Successfully published ${shiftIds.length} shifts`);
    } catch (error) {
      console.error('❌ Error publishing shifts:', error);
      throw new Error('シフトの発行に失敗しました。再度お試しください。');
    }
  }
}

// Export singleton instance
export const shiftService = ShiftManagementService.getInstance();