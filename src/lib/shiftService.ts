import { 
  collection, 
  doc, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  getDocs, 
  getDoc,
  query, 
  where, 
  orderBy, 
  limit,
  onSnapshot,
  serverTimestamp,
  writeBatch,
  runTransaction
} from 'firebase/firestore';
import { db } from './firebase';
import { 
  ShiftExtended, 
  ShiftRequestEnhanced, 
  ShiftPattern,
  User,
  ConflictRecord,
  ModificationRecord
} from '@/types';
import { logDataChange, logSystem } from './auditLogger';

export class ShiftManagementService {
  private static instance: ShiftManagementService;
  private realtimeListeners = new Map<string, () => void>();

  private constructor() {}

  public static getInstance(): ShiftManagementService {
    if (!ShiftManagementService.instance) {
      ShiftManagementService.instance = new ShiftManagementService();
    }
    return ShiftManagementService.instance;
  }

  /**
   * ã‚¹ãƒ­ãƒƒãƒˆã«æœªå‰²ã‚Šå½“ã¦ã®ã‚¹ã‚¿ãƒƒãƒ•ã‚’è‡ªå‹•å‰²ã‚Šå½“ã¦
   */
  private async autoAssignStaffToSlots(
    slots: any[],
    managerId: string,
    date: Date
  ): Promise<any[]> {
    console.log('ğŸ”„ Auto-assigning staff to slots...');

    // åˆ©ç”¨å¯èƒ½ãªã‚¹ã‚¿ãƒƒãƒ•ã‚’å–å¾—
    const availableStaff = await this.getAvailableStaff(managerId, date);

    const processedSlots = await Promise.all(slots.map(async (slot) => {
      const currentAssigned = slot.assignedStaff?.length || 0;
      const requiredStaff = slot.requiredStaff || 0;

      // æ—¢ã«ååˆ†ãªã‚¹ã‚¿ãƒƒãƒ•ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã®ã¾ã¾
      if (currentAssigned >= requiredStaff) {
        return slot;
      }

      // å¿…è¦ãªè¿½åŠ ã‚¹ã‚¿ãƒƒãƒ•æ•°
      const neededStaff = requiredStaff - currentAssigned;

      // ã‚¹ã‚­ãƒ«ãƒãƒƒãƒãƒ³ã‚°ã‚’è€ƒæ…®ã—ã¦é©åˆ‡ãªã‚¹ã‚¿ãƒƒãƒ•ã‚’é¸æŠ
      const suitableStaff = availableStaff
        .filter(staff => {
          // æ—¢ã«å‰²ã‚Šå½“ã¦æ¸ˆã¿ã§ãªã„ã“ã¨ã‚’ç¢ºèª
          if (slot.assignedStaff?.includes(staff.uid)) return false;

          // ã‚¹ã‚­ãƒ«è¦ä»¶ãƒã‚§ãƒƒã‚¯
          if (slot.requiredSkills?.length > 0) {
            const staffSkills = staff.skills || [];
            return slot.requiredSkills.some((skill: string) =>
              staffSkills.includes(skill)
            );
          }

          return true;
        })
        .slice(0, neededStaff);

      // è‡ªå‹•å‰²ã‚Šå½“ã¦
      const newAssignedStaff = [
        ...(slot.assignedStaff || []),
        ...suitableStaff.map(staff => staff.uid)
      ];

      console.log(`ğŸ“ Slot ${slot.startTime}-${slot.endTime}: ${newAssignedStaff.length}/${requiredStaff} staff assigned`);

      return {
        ...slot,
        assignedStaff: newAssignedStaff
      };
    }));

    console.log('âœ… Staff auto-assignment completed');
    return processedSlots;
  }

  /**
   * åˆ©ç”¨å¯èƒ½ãªã‚¹ã‚¿ãƒƒãƒ•ã‚’å–å¾—
   */
  private async getAvailableStaff(managerId: string, date: Date): Promise<any[]> {
    try {
      // ã‚¹ã‚¿ãƒƒãƒ•ãƒªã‚¹ãƒˆã‚’å–å¾—
      const staffQuery = query(
        collection(db, 'users'),
        where('role', '==', 'staff'),
        where('managerId', '==', managerId),
        where('status', '==', 'active')
      );

      const staffSnapshot = await getDocs(staffQuery);
      const allStaff = staffSnapshot.docs.map(doc => ({
        uid: doc.id,
        ...doc.data()
      }));

      // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ã“ã“ã§å„ã‚¹ã‚¿ãƒƒãƒ•ã®å¯ç”¨æ€§ã‚’ãƒã‚§ãƒƒã‚¯
      // ç°¡æ˜“ç‰ˆã¨ã—ã¦å…¨ã¦ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¹ã‚¿ãƒƒãƒ•ã‚’è¿”ã™
      return allStaff;
    } catch (error) {
      console.error('âŒ Error getting available staff:', error);
      return [];
    }
  }

  // ========== SHIFT CREATION & MANAGEMENT ==========

  /**
   * æ–°ã—ã„ã‚·ãƒ•ãƒˆã‚’ä½œæˆï¼ˆæ‹¡å¼µæ©Ÿèƒ½ä»˜ãï¼‰
   */
  async createShift(
    shiftData: Partial<ShiftExtended>,
    createdBy: User
  ): Promise<ShiftExtended> {
    const now = new Date();
    const shiftId = `shift_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // ã‚¹ãƒ­ãƒƒãƒˆã«æœªå‰²ã‚Šå½“ã¦ã®ã‚¹ã‚¿ãƒƒãƒ•ãŒã‚ã‚‹å ´åˆã¯è‡ªå‹•ã§å‰²ã‚Šå½“ã¦
    const processedSlots = await this.autoAssignStaffToSlots(
      shiftData.slots || [],
      shiftData.managerId!,
      shiftData.date!
    );

    const newShift: ShiftExtended = {
      shiftId,
      managerId: shiftData.managerId!,
      date: shiftData.date!,
      slots: processedSlots,
      status: 'published',
      createdBy: createdBy.uid,
      createdAt: now,
      updatedAt: now,
      metadata: {
        totalRequiredStaff: this.calculateTotalRequiredStaff(processedSlots),
        totalAssignedStaff: this.calculateTotalAssignedStaff(processedSlots),
        estimatedCost: await this.estimateShiftCost(processedSlots, shiftData.managerId!),
        complexity: this.determineShiftComplexity(processedSlots),
        autogeneratedSlots: 0,
      },
      approvalWorkflow: {
        submittedBy: createdBy.uid,
        submittedAt: now,
        lastModifiedBy: createdBy.uid,
        modificationHistory: [{
          modifiedBy: createdBy.uid,
          modifiedAt: now,
          changes: { status: { before: null, after: 'published' } },
          reason: 'Initial creation (auto-approved)'
        }]
      },
      analytics: {
        lateChanges: 0,
        noShows: 0,
      },
      realTimeSync: {
        lastSyncAt: now,
        version: 1,
        conflicts: [],
      }
    };

    try {
      const docRef = await addDoc(collection(db, 'shifts_extended'), {
        ...newShift,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        'realTimeSync.lastSyncAt': serverTimestamp(),
        'approvalWorkflow.submittedAt': serverTimestamp(),
      });

      // ãƒ­ã‚°è¨˜éŒ²
      await logDataChange(
        'Shift Created',
        createdBy.uid,
        createdBy.name,
        createdBy.role,
        `shift:${shiftId}`,
        { 
          managerId: newShift.managerId,
          date: newShift.date.toISOString(),
          slotsCount: newShift.slots.length,
          complexity: newShift.metadata.complexity
        }
      );

      return { ...newShift, id: docRef.id };
    } catch (error) {
      console.error('Error creating shift:', error);
      throw new Error('Failed to create shift');
    }
  }

  /**
   * ã‚·ãƒ•ãƒˆã‚’æ›´æ–°ï¼ˆç«¶åˆæ¤œçŸ¥ãƒ»è§£æ±ºä»˜ãï¼‰
   */
  async updateShift(
    shiftId: string,
    updates: Partial<ShiftExtended>,
    updatedBy: User,
    reason?: string
  ): Promise<ShiftExtended> {
    return runTransaction(db, async (transaction) => {
      const shiftRef = doc(db, 'shifts_extended', shiftId);
      const shiftDoc = await transaction.get(shiftRef);

      if (!shiftDoc.exists()) {
        throw new Error('Shift not found');
      }

      const currentShift = { id: shiftDoc.id, ...shiftDoc.data() } as ShiftExtended;

      // ç«¶åˆæ¤œçŸ¥
      const conflicts = await this.detectConflicts(currentShift, updates, updatedBy);
      
      if (conflicts.length > 0) {
        // è‡ªå‹•è§£æ±ºå¯èƒ½ãªç«¶åˆã‚’å‡¦ç†
        const resolvedUpdates = await this.resolveConflicts(currentShift, updates, conflicts, updatedBy);
        updates = resolvedUpdates;
      }

      const now = new Date();
      const modificationRecord: ModificationRecord = {
        modifiedBy: updatedBy.uid,
        modifiedAt: now,
        changes: this.calculateChanges(currentShift, updates),
        reason: reason || 'Manual update'
      };

      const updatedShift: Partial<ShiftExtended> = {
        ...updates,
        updatedAt: now,
        'approvalWorkflow.lastModifiedBy': updatedBy.uid,
        'approvalWorkflow.modificationHistory': [
          ...currentShift.approvalWorkflow.modificationHistory,
          modificationRecord
        ],
        'realTimeSync.lastSyncAt': now,
        'realTimeSync.version': currentShift.realTimeSync.version + 1,
        'realTimeSync.conflicts': conflicts,
        'metadata.totalRequiredStaff': updates.slots ? 
          this.calculateTotalRequiredStaff(updates.slots) : 
          currentShift.metadata.totalRequiredStaff,
        'metadata.totalAssignedStaff': updates.slots ? 
          this.calculateTotalAssignedStaff(updates.slots) : 
          currentShift.metadata.totalAssignedStaff,
      };

      transaction.update(shiftRef, {
        ...updatedShift,
        updatedAt: serverTimestamp(),
        'realTimeSync.lastSyncAt': serverTimestamp(),
      });

      // ãƒ­ã‚°è¨˜éŒ²
      await logDataChange(
        'Shift Updated',
        updatedBy.uid,
        updatedBy.name,
        updatedBy.role,
        `shift:${shiftId}`,
        { 
          changes: modificationRecord.changes,
          reason: modificationRecord.reason,
          conflictsDetected: conflicts.length
        }
      );

      return { ...currentShift, ...updatedShift };
    });
  }

  /**
   * ã‚·ãƒ•ãƒˆã®æ‰¿èªå‡¦ç†
   */
  async approveShift(
    shiftId: string,
    approvedBy: User,
    notes?: string
  ): Promise<ShiftExtended> {
    const shiftRef = doc(db, 'shifts_extended', shiftId);
    const now = new Date();

    const updates = {
      status: 'published' as const,
      'approvalWorkflow.approvedBy': approvedBy.uid,
      'approvalWorkflow.approvedAt': now,
      'approvalWorkflow.lastModifiedBy': approvedBy.uid,
      updatedAt: now,
      'realTimeSync.lastSyncAt': now,
    };

    await updateDoc(shiftRef, {
      ...updates,
      'approvalWorkflow.approvedAt': serverTimestamp(),
      updatedAt: serverTimestamp(),
      'realTimeSync.lastSyncAt': serverTimestamp(),
    });

    // é€šçŸ¥ãƒ»ãƒ­ã‚°å‡¦ç†
    await this.notifyShiftApproval(shiftId, approvedBy, notes);
    
    await logDataChange(
      'Shift Approved',
      approvedBy.uid,
      approvedBy.name,
      approvedBy.role,
      `shift:${shiftId}`,
      { notes, timestamp: now.toISOString() }
    );

    // æ›´æ–°ã•ã‚ŒãŸã‚·ãƒ•ãƒˆã‚’å–å¾—
    const updatedDoc = await getDoc(shiftRef);
    return { id: updatedDoc.id, ...updatedDoc.data() } as ShiftExtended;
  }

  // ========== REAL-TIME SYNC ==========

  /**
   * ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸã®é–‹å§‹
   */
  subscribeToShiftUpdates(
    managerId: string, 
    callback: (shifts: ShiftExtended[]) => void
  ): () => void {
    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚¨ãƒ©ãƒ¼ã‚’å›é¿ã™ã‚‹ãŸã‚ã€ã‚ˆã‚Šå˜ç´”ãªã‚¯ã‚¨ãƒªã‚’ä½¿ç”¨
    const q = query(
      collection(db, 'shifts_extended'),
      where('managerId', '==', managerId),
      limit(50)
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const allShifts = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        // Firestoreã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’å¤‰æ›
        date: doc.data().date?.toDate() || new Date(),
        createdAt: doc.data().createdAt?.toDate() || new Date(),
        updatedAt: doc.data().updatedAt?.toDate() || new Date(),
      })) as ShiftExtended[];

      // ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¨ã‚½ãƒ¼ãƒˆ
      const filteredShifts = allShifts
        .filter(shift => ['draft', 'published'].includes(shift.status))
        .sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

      callback(filteredShifts);

      // ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨˜éŒ²
      this.trackRealtimeMetrics(filteredShifts.length, !snapshot.metadata.fromCache);
    }, (error) => {
      console.error('âŒ Error in shift subscription:', error);
      // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ç©ºã®é…åˆ—ã‚’è¿”ã™
      callback([]);
    });

    this.realtimeListeners.set(`shifts:${managerId}`, unsubscribe);
    return unsubscribe;
  }

  /**
   * ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸã®åœæ­¢
   */
  unsubscribeFromShiftUpdates(managerId: string): void {
    const unsubscribe = this.realtimeListeners.get(`shifts:${managerId}`);
    if (unsubscribe) {
      unsubscribe();
      this.realtimeListeners.delete(`shifts:${managerId}`);
    }
  }

  /**
   * ã‚·ãƒ•ãƒˆã‚’å‰Šé™¤
   */
  async deleteShift(shiftId: string, deletedBy: User): Promise<void> {
    const shiftRef = doc(db, 'shifts_extended', shiftId);
    
    try {
      const shiftDoc = await getDoc(shiftRef);
      if (!shiftDoc.exists()) {
        throw new Error('ã‚·ãƒ•ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
      }

      const shiftData = shiftDoc.data() as ShiftExtended;
      
      // å‰Šé™¤å¯èƒ½ï¼ˆåˆ¶é™ãªã—ï¼‰

      // ãƒ­ã‚°è¨˜éŒ²
      await logDataChange({
        operation: 'DELETE',
        entityType: 'shift',
        entityId: shiftId,
        userId: deletedBy.uid,
        changes: { status: { before: shiftData.status, after: 'deleted' } },
        timestamp: new Date()
      });

      // Firestoreã‹ã‚‰å‰Šé™¤
      await deleteDoc(shiftRef);
      
      console.log(`âœ… Shift ${shiftId} deleted successfully by ${deletedBy.name}`);
      
    } catch (error) {
      console.error('âŒ Error deleting shift:', error);
      throw error;
    }
  }

  // ========== HELPER METHODS ==========

  private calculateTotalRequiredStaff(slots: any[]): number {
    return slots.reduce((total, slot) => total + (slot.requiredStaff || 0), 0);
  }

  private calculateTotalAssignedStaff(slots: any[]): number {
    return slots.reduce((total, slot) => total + (slot.assignedStaff?.length || 0), 0);
  }

  private async estimateShiftCost(slots: any[], managerId: string): Promise<number> {
    // åŸºæœ¬çš„ãªæ™‚çµ¦è¨ˆç®—ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯åº—èˆ—å›ºæœ‰ã®ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ï¼‰
    const baseHourlyRate = 1200; // åŸºæœ¬æ™‚çµ¦
    
    let totalCost = 0;
    for (const slot of slots) {
      const duration = this.calculateSlotDuration(slot.startTime, slot.endTime);
      const staffCount = slot.requiredStaff || 0;
      totalCost += (duration / 60) * staffCount * baseHourlyRate;
    }
    
    return Math.round(totalCost);
  }

  private calculateSlotDuration(startTime: string, endTime: string): number {
    const start = new Date(`2000-01-01T${startTime}`);
    const end = new Date(`2000-01-01T${endTime}`);
    return (end.getTime() - start.getTime()) / (1000 * 60); // minutes
  }

  private determineShiftComplexity(slots: any[]): 'simple' | 'moderate' | 'complex' {
    const totalSlots = slots.length;
    const totalStaff = this.calculateTotalRequiredStaff(slots);
    const hasSkillRequirements = slots.some(slot => slot.requiredSkills?.length > 0);

    if (totalSlots > 10 || totalStaff > 20 || hasSkillRequirements) {
      return 'complex';
    } else if (totalSlots > 5 || totalStaff > 10) {
      return 'moderate';
    } else {
      return 'simple';
    }
  }

  /**
   * é«˜åº¦ãªç«¶åˆæ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ  - Phase 3.1å¯¾å¿œ
   */
  private async detectConflicts(
    currentShift: ShiftExtended, 
    updates: Partial<ShiftExtended>, 
    updatedBy: User
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];

    // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç«¶åˆãƒã‚§ãƒƒã‚¯
    if (updates.realTimeSync && 
        currentShift.realTimeSync.version !== updates.realTimeSync.version) {
      conflicts.push({
        conflictId: `version_conflict_${Date.now()}`,
        type: 'concurrent_edit',
        description: 'Concurrent modification detected',
        affectedFields: ['version'],
      });
    }

    // ã‚¹ã‚¿ãƒƒãƒ•å‰²ã‚Šå½“ã¦ç«¶åˆãƒã‚§ãƒƒã‚¯
    if (updates.slots) {
      const staffConflicts = await this.detectStaffConflicts(currentShift, updates);
      conflicts.push(...staffConflicts);

      // æ™‚é–“å¸¯é‡è¤‡ãƒã‚§ãƒƒã‚¯
      const timeConflicts = await this.detectTimeConflicts(currentShift, updates);
      conflicts.push(...timeConflicts);

      // ã‚¹ã‚­ãƒ«è¦ä»¶ç«¶åˆãƒã‚§ãƒƒã‚¯
      const skillConflicts = await this.detectSkillConflicts(currentShift, updates);
      conflicts.push(...skillConflicts);

      // æœ€å°ã‚¹ã‚¿ãƒƒãƒ•æ•°ä¸è¶³ãƒã‚§ãƒƒã‚¯
      const staffingConflicts = await this.detectStaffingConflicts(currentShift, updates);
      conflicts.push(...staffingConflicts);
    }

    return conflicts;
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•å‰²ã‚Šå½“ã¦ç«¶åˆã®æ¤œçŸ¥
   */
  private async detectStaffConflicts(
    currentShift: ShiftExtended,
    updates: Partial<ShiftExtended>
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];
    
    if (!updates.slots) return conflicts;

    // åŒã˜ã‚¹ã‚¿ãƒƒãƒ•ãŒè¤‡æ•°ã‚¹ãƒ­ãƒƒãƒˆã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const allAssignedStaff = updates.slots.flatMap(slot => slot.assignedStaff || []);
    const duplicateStaff = allAssignedStaff.filter((staff, index, arr) => 
      arr.indexOf(staff) !== index
    );

    if (duplicateStaff.length > 0) {
      conflicts.push({
        conflictId: `staff_duplicate_${Date.now()}`,
        type: 'data_mismatch',
        description: `Duplicate staff assignments detected: ${duplicateStaff.join(', ')}`,
        affectedFields: ['slots.assignedStaff'],
      });
    }

    // ä»–ã®ã‚·ãƒ•ãƒˆã¨ã®é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆåŒã˜æ™‚é–“å¸¯ï¼‰
    const conflictingShifts = await this.checkCrossShiftConflicts(
      currentShift.managerId,
      currentShift.date,
      updates.slots
    );

    conflicts.push(...conflictingShifts);

    return conflicts;
  }

  /**
   * æ™‚é–“å¸¯ç«¶åˆã®æ¤œçŸ¥
   */
  private async detectTimeConflicts(
    currentShift: ShiftExtended,
    updates: Partial<ShiftExtended>
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];
    
    if (!updates.slots) return conflicts;

    // ã‚¹ãƒ­ãƒƒãƒˆé–“ã®æ™‚é–“é‡è¤‡ãƒã‚§ãƒƒã‚¯
    for (let i = 0; i < updates.slots.length; i++) {
      for (let j = i + 1; j < updates.slots.length; j++) {
        const slot1 = updates.slots[i];
        const slot2 = updates.slots[j];
        
        if (this.isTimeOverlapping(slot1.startTime, slot1.endTime, slot2.startTime, slot2.endTime)) {
          // åŒã˜ã‚¹ã‚¿ãƒƒãƒ•ãŒé‡è¤‡ã™ã‚‹æ™‚é–“å¸¯ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
          const commonStaff = (slot1.assignedStaff || []).filter(staff => 
            (slot2.assignedStaff || []).includes(staff)
          );
          
          if (commonStaff.length > 0) {
            conflicts.push({
              conflictId: `time_overlap_${Date.now()}_${i}_${j}`,
              type: 'data_mismatch',
              description: `Time overlap conflict: ${commonStaff.join(', ')} assigned to overlapping slots`,
              affectedFields: [`slots.${i}.assignedStaff`, `slots.${j}.assignedStaff`],
            });
          }
        }
      }
    }

    return conflicts;
  }

  /**
   * ã‚¹ã‚­ãƒ«è¦ä»¶ç«¶åˆã®æ¤œçŸ¥
   */
  private async detectSkillConflicts(
    currentShift: ShiftExtended,
    updates: Partial<ShiftExtended>
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];
    
    if (!updates.slots) return conflicts;

    for (const [slotIndex, slot] of updates.slots.entries()) {
      if (slot.requiredSkills && slot.assignedStaff) {
        for (const staffId of slot.assignedStaff) {
          // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ã‚¹ã‚¿ãƒƒãƒ•ã®ã‚¹ã‚­ãƒ«æƒ…å ±ã‚’å–å¾—ã—ã¦æ¯”è¼ƒ
          // ã“ã“ã§ã¯ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…
          const staffSkills = await this.getStaffSkills(staffId);
          const missingSkills = slot.requiredSkills.filter(skill => 
            !staffSkills.includes(skill)
          );
          
          if (missingSkills.length > 0) {
            conflicts.push({
              conflictId: `skill_mismatch_${Date.now()}_${slotIndex}_${staffId}`,
              type: 'data_mismatch',
              description: `Staff ${staffId} lacks required skills: ${missingSkills.join(', ')}`,
              affectedFields: [`slots.${slotIndex}.assignedStaff`],
            });
          }
        }
      }
    }

    return conflicts;
  }

  /**
   * æœ€å°ã‚¹ã‚¿ãƒƒãƒ•æ•°ç«¶åˆã®æ¤œçŸ¥
   */
  private async detectStaffingConflicts(
    currentShift: ShiftExtended,
    updates: Partial<ShiftExtended>
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];
    
    if (!updates.slots) return conflicts;

    for (const [slotIndex, slot] of updates.slots.entries()) {
      const assignedCount = slot.assignedStaff?.length || 0;
      const requiredCount = slot.requiredStaff || 0;
      
      if (assignedCount < requiredCount) {
        conflicts.push({
          conflictId: `understaffed_${Date.now()}_${slotIndex}`,
          type: 'data_mismatch',
          description: `Slot understaffed: ${assignedCount}/${requiredCount} staff assigned`,
          affectedFields: [`slots.${slotIndex}.assignedStaff`],
        });
      } else if (assignedCount > requiredCount * 1.2) { // 20%è¶…éã§è­¦å‘Š
        conflicts.push({
          conflictId: `overstaffed_${Date.now()}_${slotIndex}`,
          type: 'data_mismatch',
          description: `Slot overstaffed: ${assignedCount}/${requiredCount} staff assigned`,
          affectedFields: [`slots.${slotIndex}.assignedStaff`],
        });
      }
    }

    return conflicts;
  }

  /**
   * ä»–ã®ã‚·ãƒ•ãƒˆã¨ã®ç«¶åˆãƒã‚§ãƒƒã‚¯
   */
  private async checkCrossShiftConflicts(
    managerId: string,
    date: Date,
    slots: any[]
  ): Promise<ConflictRecord[]> {
    const conflicts: ConflictRecord[] = [];

    // åŒã˜æ—¥ã®ä»–ã®ã‚·ãƒ•ãƒˆã‚’å–å¾—
    const existingShifts = await this.getShiftsByShop(managerId, date, date);
    
    for (const existingShift of existingShifts) {
      for (const newSlot of slots) {
        for (const existingSlot of existingShift.slots) {
          // æ™‚é–“é‡è¤‡ãƒã‚§ãƒƒã‚¯
          if (this.isTimeOverlapping(
            newSlot.startTime, newSlot.endTime,
            existingSlot.startTime, existingSlot.endTime
          )) {
            // åŒã˜ã‚¹ã‚¿ãƒƒãƒ•ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const commonStaff = (newSlot.assignedStaff || []).filter(staff => 
              (existingSlot.assignedStaff || []).includes(staff)
            );
            
            if (commonStaff.length > 0) {
              conflicts.push({
                conflictId: `cross_shift_conflict_${Date.now()}_${existingShift.shiftId}`,
                type: 'data_mismatch',
                description: `Staff ${commonStaff.join(', ')} assigned to overlapping shifts`,
                affectedFields: ['slots.assignedStaff'],
              });
            }
          }
        }
      }
    }

    return conflicts;
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ã®ã‚¹ã‚­ãƒ«æƒ…å ±ã‚’å–å¾—
   */
  private async getStaffSkills(staffId: string): Promise<string[]> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‹ã‚‰ã‚¹ã‚­ãƒ«ã‚’å–å¾—
    // ã“ã“ã§ã¯ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…
    const sampleSkills: Record<string, string[]> = {
      'staff1': ['ãƒ¬ã‚¸', 'æ¥å®¢', 'å•†å“çŸ¥è­˜'],
      'staff2': ['ã‚­ãƒƒãƒãƒ³', 'èª¿ç†', 'è¡›ç”Ÿç®¡ç†'],
      'staff3': ['ãƒ•ãƒ­ã‚¢', 'æ¸…æƒ', 'å•†å“é™³åˆ—'],
    };
    
    return sampleSkills[staffId] || [];
  }

  /**
   * æ™‚é–“é‡è¤‡åˆ¤å®š
   */
  private isTimeOverlapping(
    start1: string,
    end1: string,
    start2: string,
    end2: string
  ): boolean {
    const start1Time = new Date(`2000-01-01T${start1}`);
    const end1Time = new Date(`2000-01-01T${end1}`);
    const start2Time = new Date(`2000-01-01T${start2}`);
    const end2Time = new Date(`2000-01-01T${end2}`);
    
    return (start1Time < end2Time) && (start2Time < end1Time);
  }

  /**
   * é«˜åº¦ãªç«¶åˆè§£æ±ºã‚·ã‚¹ãƒ†ãƒ  - Phase 3.1å¯¾å¿œ
   */
  private async resolveConflicts(
    currentShift: ShiftExtended,
    updates: Partial<ShiftExtended>,
    conflicts: ConflictRecord[],
    updatedBy: User
  ): Promise<Partial<ShiftExtended>> {
    let resolvedUpdates = { ...updates };

    for (const conflict of conflicts) {
      switch (conflict.type) {
        case 'concurrent_edit':
          resolvedUpdates = await this.resolveConcurrentEdit(conflict, resolvedUpdates, updatedBy);
          break;
        
        case 'data_mismatch':
          resolvedUpdates = await this.resolveDataMismatch(conflict, resolvedUpdates, currentShift, updatedBy);
          break;
        
        default:
          // è§£æ±ºä¸å¯èƒ½ãªç«¶åˆã¯æ‰‹å‹•å¯¾å¿œãŒå¿…è¦
          conflict.resolutionMethod = 'manual';
      }
    }

    return resolvedUpdates;
  }

  /**
   * åŒæ™‚ç·¨é›†ç«¶åˆã®è§£æ±º
   */
  private async resolveConcurrentEdit(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    updatedBy: User
  ): Promise<Partial<ShiftExtended>> {
    // Rootæ¨©é™è€…ã¯å¸¸ã«å„ªå…ˆ
    if (updatedBy.role === 'root') {
      conflict.resolvedAt = new Date();
      conflict.resolvedBy = updatedBy.uid;
      conflict.resolutionMethod = 'automatic';
      return updates;
    }

    // Manageræ¨©é™è€…ã¯é€šå¸¸å„ªå…ˆï¼ˆãŸã ã—ä»–ã®Managerã¨ã®ç«¶åˆæ™‚ã¯æ™‚é–“é †ï¼‰
    if (updatedBy.role === 'manager') {
      conflict.resolvedAt = new Date();
      conflict.resolvedBy = updatedBy.uid;
      conflict.resolutionMethod = 'automatic';
      return updates;
    }

    // Staffæ¨©é™è€…ã¯æ‰‹å‹•è§£æ±ºãŒå¿…è¦
    conflict.resolutionMethod = 'manual';
    return updates;
  }

  /**
   * ãƒ‡ãƒ¼ã‚¿ä¸æ•´åˆç«¶åˆã®è§£æ±º
   */
  private async resolveDataMismatch(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    currentShift: ShiftExtended,
    updatedBy: User
  ): Promise<Partial<ShiftExtended>> {
    if (conflict.conflictId.includes('understaffed')) {
      // ã‚¹ã‚¿ãƒƒãƒ•ä¸è¶³ã®å ´åˆã€åˆ©ç”¨å¯èƒ½ãªã‚¹ã‚¿ãƒƒãƒ•ã‚’è‡ªå‹•ææ¡ˆ
      return await this.resolveUnderstaffing(conflict, updates, currentShift);
    }
    
    if (conflict.conflictId.includes('overstaffed')) {
      // ã‚¹ã‚¿ãƒƒãƒ•éå¤šã®å ´åˆã€é©åˆ‡ãªã‚¹ã‚¿ãƒƒãƒ•æ•°ã«èª¿æ•´
      return await this.resolveOverstaffing(conflict, updates, currentShift);
    }
    
    if (conflict.conflictId.includes('skill_mismatch')) {
      // ã‚¹ã‚­ãƒ«ä¸ä¸€è‡´ã®å ´åˆã€ä»£æ›¿ã‚¹ã‚¿ãƒƒãƒ•ã‚’ææ¡ˆ
      return await this.resolveSkillMismatch(conflict, updates, currentShift);
    }
    
    if (conflict.conflictId.includes('duplicate') || conflict.conflictId.includes('overlap')) {
      // é‡è¤‡å‰²ã‚Šå½“ã¦ã®å ´åˆã€å„ªå…ˆåº¦ã«åŸºã¥ã„ã¦èª¿æ•´
      return await this.resolveDuplicateAssignment(conflict, updates, currentShift);
    }

    // è‡ªå‹•è§£æ±ºä¸å¯èƒ½ãªå ´åˆ
    conflict.resolutionMethod = 'escalated';
    return updates;
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ä¸è¶³å•é¡Œã®è§£æ±º
   */
  private async resolveUnderstaffing(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    currentShift: ShiftExtended
  ): Promise<Partial<ShiftExtended>> {
    if (!updates.slots) return updates;

    // å½±éŸ¿ã‚’å—ã‘ã‚‹ã‚¹ãƒ­ãƒƒãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æŠ½å‡º
    const slotIndex = this.extractSlotIndex(conflict.affectedFields[0]);
    if (slotIndex === -1) return updates;

    const slot = updates.slots[slotIndex];
    const requiredStaff = slot.requiredStaff || 0;
    const currentStaff = slot.assignedStaff?.length || 0;
    const neededStaff = requiredStaff - currentStaff;

    // åˆ©ç”¨å¯èƒ½ãªã‚¹ã‚¿ãƒƒãƒ•ã‚’æ¤œç´¢
    const availableStaff = await this.findAvailableStaff(
      currentShift.managerId,
      currentShift.date,
      slot.startTime,
      slot.endTime,
      slot.requiredSkills || []
    );

    if (availableStaff.length >= neededStaff) {
      // è‡ªå‹•çš„ã«ã‚¹ã‚¿ãƒƒãƒ•ã‚’å‰²ã‚Šå½“ã¦
      const staffToAssign = availableStaff.slice(0, neededStaff);
      updates.slots[slotIndex] = {
        ...slot,
        assignedStaff: [...(slot.assignedStaff || []), ...staffToAssign.map(s => s.uid)]
      };
      
      conflict.resolvedAt = new Date();
      conflict.resolutionMethod = 'automatic';
      conflict.description += ` - Auto-assigned: ${staffToAssign.map(s => s.name).join(', ')}`;
    } else {
      // éƒ¨åˆ†çš„ãªè§£æ±º
      if (availableStaff.length > 0) {
        updates.slots[slotIndex] = {
          ...slot,
          assignedStaff: [...(slot.assignedStaff || []), ...availableStaff.map(s => s.uid)]
        };
        conflict.resolutionMethod = 'manual';
        conflict.description += ` - Partially resolved: ${availableStaff.length}/${neededStaff} staff assigned`;
      } else {
        conflict.resolutionMethod = 'escalated';
      }
    }

    return updates;
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•éå¤šå•é¡Œã®è§£æ±º
   */
  private async resolveOverstaffing(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    currentShift: ShiftExtended
  ): Promise<Partial<ShiftExtended>> {
    if (!updates.slots) return updates;

    const slotIndex = this.extractSlotIndex(conflict.affectedFields[0]);
    if (slotIndex === -1) return updates;

    const slot = updates.slots[slotIndex];
    const requiredStaff = slot.requiredStaff || 0;
    const currentStaff = slot.assignedStaff || [];
    
    if (currentStaff.length > requiredStaff) {
      // å„ªå…ˆåº¦ã«åŸºã¥ã„ã¦ã‚¹ã‚¿ãƒƒãƒ•ã‚’å‰Šæ¸›ï¼ˆçµŒé¨“ã€éå»ã®è©•ä¾¡ãªã©ã«åŸºã¥ãï¼‰
      const staffToKeep = await this.selectOptimalStaff(
        currentStaff, 
        requiredStaff, 
        slot.requiredSkills || []
      );
      
      updates.slots[slotIndex] = {
        ...slot,
        assignedStaff: staffToKeep
      };
      
      conflict.resolvedAt = new Date();
      conflict.resolutionMethod = 'automatic';
    }

    return updates;
  }

  /**
   * ã‚¹ã‚­ãƒ«ä¸ä¸€è‡´å•é¡Œã®è§£æ±º
   */
  private async resolveSkillMismatch(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    currentShift: ShiftExtended
  ): Promise<Partial<ShiftExtended>> {
    if (!updates.slots) return updates;

    const slotIndex = this.extractSlotIndex(conflict.affectedFields[0]);
    if (slotIndex === -1) return updates;

    const slot = updates.slots[slotIndex];
    
    // ã‚¹ã‚­ãƒ«è¦ä»¶ã‚’æº€ãŸã™ã‚¹ã‚¿ãƒƒãƒ•ã‚’æ¤œç´¢
    const qualifiedStaff = await this.findQualifiedStaff(
      currentShift.managerId,
      currentShift.date,
      slot.startTime,
      slot.endTime,
      slot.requiredSkills || []
    );

    if (qualifiedStaff.length >= (slot.requiredStaff || 0)) {
      // é©æ ¼ãªã‚¹ã‚¿ãƒƒãƒ•ã«ç½®ãæ›ãˆ
      const selectedStaff = qualifiedStaff.slice(0, slot.requiredStaff || 0);
      updates.slots[slotIndex] = {
        ...slot,
        assignedStaff: selectedStaff.map(s => s.uid)
      };
      
      conflict.resolvedAt = new Date();
      conflict.resolutionMethod = 'automatic';
    } else {
      conflict.resolutionMethod = 'manual';
    }

    return updates;
  }

  /**
   * é‡è¤‡å‰²ã‚Šå½“ã¦å•é¡Œã®è§£æ±º
   */
  private async resolveDuplicateAssignment(
    conflict: ConflictRecord,
    updates: Partial<ShiftExtended>,
    currentShift: ShiftExtended
  ): Promise<Partial<ShiftExtended>> {
    if (!updates.slots) return updates;

    // é‡è¤‡ã—ã¦ã„ã‚‹ã‚¹ã‚¿ãƒƒãƒ•ã‚’ç‰¹å®š
    const duplicateStaffIds = this.extractDuplicateStaff(conflict.description);
    
    for (const staffId of duplicateStaffIds) {
      // æœ€ã‚‚é‡è¦ãªã‚¹ãƒ­ãƒƒãƒˆï¼ˆå„ªå…ˆåº¦ãŒé«˜ã„ï¼‰ã«å‰²ã‚Šå½“ã¦ã€ä»–ã‹ã‚‰å‰Šé™¤
      const slotsWithStaff = updates.slots
        .map((slot, index) => ({ slot, index }))
        .filter(({ slot }) => slot.assignedStaff?.includes(staffId));
      
      if (slotsWithStaff.length > 1) {
        // å„ªå…ˆåº¦ãŒæœ€ã‚‚é«˜ã„ã‚¹ãƒ­ãƒƒãƒˆã‚’ä¿æŒ
        const highestPrioritySlot = slotsWithStaff.reduce((prev, current) => 
          this.getSlotPriority(current.slot) > this.getSlotPriority(prev.slot) ? current : prev
        );
        
        // ä»–ã®ã‚¹ãƒ­ãƒƒãƒˆã‹ã‚‰å‰Šé™¤
        slotsWithStaff.forEach(({ slot, index }) => {
          if (index !== highestPrioritySlot.index) {
            updates.slots![index] = {
              ...slot,
              assignedStaff: slot.assignedStaff?.filter(id => id !== staffId) || []
            };
          }
        });
      }
    }

    conflict.resolvedAt = new Date();
    conflict.resolutionMethod = 'automatic';
    return updates;
  }

  /**
   * åˆ©ç”¨å¯èƒ½ãªã‚¹ã‚¿ãƒƒãƒ•ã‚’æ¤œç´¢
   */
  private async findAvailableStaff(
    managerId: string,
    date: Date,
    startTime: string,
    endTime: string,
    requiredSkills: string[]
  ): Promise<User[]> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰ã‚¹ã‚¿ãƒƒãƒ•ã‚’æ¤œç´¢
    // ã“ã“ã§ã¯ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…
    const sampleStaff: User[] = [
      {
        uid: 'staff4',
        email: 'staff4@example.com',
        name: 'éˆ´æœ¨ä¸€éƒ',
        role: 'staff',
        managerId,
        skills: ['ãƒ¬ã‚¸', 'æ¥å®¢'],
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        uid: 'staff5',
        email: 'staff5@example.com',
        name: 'ç”°ä¸­èŠ±å­',
        role: 'staff',
        managerId,
        skills: ['ãƒ•ãƒ­ã‚¢', 'æ¸…æƒ'],
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];

    // ã‚¹ã‚­ãƒ«è¦ä»¶ã¨æ™‚é–“å¯ç”¨æ€§ã‚’ãƒã‚§ãƒƒã‚¯
    return sampleStaff.filter(staff => 
      this.hasRequiredSkills(staff.skills || [], requiredSkills) &&
      this.isStaffAvailable(staff.uid, date, startTime, endTime)
    );
  }

  /**
   * é©æ ¼ãªã‚¹ã‚¿ãƒƒãƒ•ã‚’æ¤œç´¢
   */
  private async findQualifiedStaff(
    managerId: string,
    date: Date,
    startTime: string,
    endTime: string,
    requiredSkills: string[]
  ): Promise<User[]> {
    const availableStaff = await this.findAvailableStaff(managerId, date, startTime, endTime, requiredSkills);
    return availableStaff.filter(staff => 
      this.hasRequiredSkills(staff.skills || [], requiredSkills)
    );
  }

  /**
   * æœ€é©ãªã‚¹ã‚¿ãƒƒãƒ•ã‚’é¸æŠ
   */
  private async selectOptimalStaff(
    staffIds: string[],
    requiredCount: number,
    requiredSkills: string[]
  ): Promise<string[]> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ã‚¹ã‚¿ãƒƒãƒ•ã®è©•ä¾¡ã€çµŒé¨“ã€ã‚¹ã‚­ãƒ«ãƒãƒƒãƒãƒ³ã‚°ç­‰ã‚’è€ƒæ…®
    // ã“ã“ã§ã¯ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…ï¼ˆã‚¹ã‚­ãƒ«ä¿æœ‰æ•°ã§ã‚½ãƒ¼ãƒˆï¼‰
    const staffWithSkills = await Promise.all(
      staffIds.map(async id => {
        const skills = await this.getStaffSkills(id);
        const skillMatch = skills.filter(skill => requiredSkills.includes(skill)).length;
        return { id, skillMatch };
      })
    );

    return staffWithSkills
      .sort((a, b) => b.skillMatch - a.skillMatch)
      .slice(0, requiredCount)
      .map(s => s.id);
  }

  /**
   * ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰ç¾¤
   */
  private extractSlotIndex(affectedField: string): number {
    const match = affectedField.match(/slots\.(\d+)/);
    return match ? parseInt(match[1]) : -1;
  }

  private extractDuplicateStaff(description: string): string[] {
    const match = description.match(/: (.+?)(?:\s|$)/);
    return match ? match[1].split(', ') : [];
  }

  private getSlotPriority(slot: any): number {
    const priorityMap = { 'critical': 4, 'high': 3, 'medium': 2, 'low': 1 };
    return priorityMap[slot.priority as keyof typeof priorityMap] || 1;
  }

  private hasRequiredSkills(staffSkills: string[], requiredSkills: string[]): boolean {
    return requiredSkills.every(skill => staffSkills.includes(skill));
  }

  private async isStaffAvailable(staffId: string, date: Date, startTime: string, endTime: string): Promise<boolean> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€ã‚¹ã‚¿ãƒƒãƒ•ã®å¯ç”¨æ€§ã‚’ãƒã‚§ãƒƒã‚¯
    // ã“ã“ã§ã¯ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…
    return true;
  }

  private calculateChanges(current: ShiftExtended, updates: Partial<ShiftExtended>): Record<string, { before: any; after: any }> {
    const changes: Record<string, { before: any; after: any }> = {};

    Object.keys(updates).forEach(key => {
      const beforeValue = (current as any)[key];
      const afterValue = (updates as any)[key];
      
      if (JSON.stringify(beforeValue) !== JSON.stringify(afterValue)) {
        changes[key] = { before: beforeValue, after: afterValue };
      }
    });

    return changes;
  }

  private async notifyShiftApproval(shiftId: string, approvedBy: User, notes?: string): Promise<void> {
    // å®Ÿè£…: ã‚¹ã‚¿ãƒƒãƒ•ã¸ã®é€šçŸ¥é€ä¿¡
    console.log(`ğŸ”” Shift ${shiftId} approved by ${approvedBy.name}`);
  }

  private trackRealtimeMetrics(shiftCount: number, fromServer: boolean): void {
    // å®Ÿè£…: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨˜éŒ²
    console.log(`ğŸ“Š Realtime sync: ${shiftCount} shifts, from server: ${fromServer}`);
  }

  // ========== SHIFT GENERATION ENGINE - Phase 3.1 ==========

  /**
   * è‡ªå‹•ã‚·ãƒ•ãƒˆç”Ÿæˆã‚¨ãƒ³ã‚¸ãƒ³ - AIæœ€é©åŒ–å¯¾å¿œ
   */
  async generateOptimalShift(
    managerId: string,
    date: Date,
    requirements: ShiftGenerationRequirements,
    generatedBy: User
  ): Promise<ShiftExtended> {
    console.log(`ğŸ”„ Starting shift generation for ${managerId} on ${date.toISOString()}`);
    
    // Step 1: åŸºæœ¬åˆ¶ç´„ã®åé›†
    const constraints = await this.collectShiftConstraints(managerId, date, requirements);
    
    // Step 2: ã‚¹ã‚¿ãƒƒãƒ•å¯ç”¨æ€§ã®åˆ†æ
    const staffAvailability = await this.analyzeStaffAvailability(managerId, date);
    
    // Step 3: æœ€é©åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè¡Œ
    const optimizedSlots = await this.runOptimizationEngine(constraints, staffAvailability, requirements);
    
    // Step 4: ã‚·ãƒ•ãƒˆã®æ§‹ç¯‰
    const generatedShift = await this.constructOptimalShift(
      managerId, 
      date, 
      optimizedSlots, 
      requirements, 
      generatedBy
    );
    
    // Step 5: å“è³ªæ¤œè¨¼
    const qualityScore = await this.validateShiftQuality(generatedShift);
    
    // Step 6: ä¿å­˜ã¨ãƒ­ã‚°
    const savedShift = await this.saveGeneratedShift(generatedShift, qualityScore, generatedBy);
    
    console.log(`âœ… Shift generation completed with quality score: ${qualityScore}`);
    return savedShift;
  }

  /**
   * åˆ¶ç´„æ¡ä»¶ã®åé›†
   */
  private async collectShiftConstraints(
    managerId: string, 
    date: Date, 
    requirements: ShiftGenerationRequirements
  ): Promise<ShiftConstraints> {
    const constraints: ShiftConstraints = {
      businessHours: requirements.businessHours || { start: '09:00', end: '21:00' },
      minimumStaffPerSlot: requirements.minimumStaffPerSlot || 2,
      maximumStaffPerSlot: requirements.maximumStaffPerSlot || 6,
      requiredSkills: requirements.requiredSkills || [],
      budgetLimit: requirements.budgetLimit,
      specialRequirements: requirements.specialRequirements || [],
      
      // æ›œæ—¥åˆ¥åˆ¶ç´„
      dayOfWeekConstraints: this.getDayOfWeekConstraints(date),
      
      // æ³•çš„åˆ¶ç´„ï¼ˆåŠ´åƒåŸºæº–æ³•ç­‰ï¼‰
      legalConstraints: {
        maxConsecutiveHours: 8,
        minBreakTime: 60,
        maxWeeklyHours: 40
      },
      
      // éå»ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ‡ãƒ¼ã‚¿
      historicalData: await this.getHistoricalShiftData(managerId, date)
    };

    return constraints;
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•å¯ç”¨æ€§ã®åˆ†æ
   */
  private async analyzeStaffAvailability(
    managerId: string, 
    date: Date
  ): Promise<StaffAvailabilityMatrix> {
    // ã‚¹ã‚¿ãƒƒãƒ•ã®å¸Œæœ›ã‚·ãƒ•ãƒˆã‚’å–å¾—
    const shiftRequests = await this.getShiftRequestsForDate(managerId, date);
    
    // ã‚¹ã‚¿ãƒƒãƒ•ã®ã‚¹ã‚­ãƒ«ã¨çµŒé¨“ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—
    const staffProfiles = await this.getStaffProfiles(managerId);
    
    // æ—¢å­˜ã®ã‚·ãƒ•ãƒˆå‰²ã‚Šå½“ã¦ã‚’ãƒã‚§ãƒƒã‚¯
    const existingAssignments = await this.getExistingAssignments(managerId, date);
    
    // å¯ç”¨æ€§ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã‚’æ§‹ç¯‰
    const availabilityMatrix: StaffAvailabilityMatrix = {
      date,
      staffAvailability: new Map(),
      skillMatrix: new Map(),
      preferenceScores: new Map(),
      conflictIndicators: new Map()
    };

    for (const staff of staffProfiles) {
      // åŸºæœ¬çš„ãªå¯ç”¨æ€§
      const availability = this.calculateStaffAvailability(staff, shiftRequests, existingAssignments);
      availabilityMatrix.staffAvailability.set(staff.uid, availability);
      
      // ã‚¹ã‚­ãƒ«ãƒãƒƒãƒ”ãƒ³ã‚°
      availabilityMatrix.skillMatrix.set(staff.uid, staff.skills || []);
      
      // å¸Œæœ›åº¦ã‚¹ã‚³ã‚¢
      const preferenceScore = this.calculatePreferenceScore(staff.uid, shiftRequests);
      availabilityMatrix.preferenceScores.set(staff.uid, preferenceScore);
      
      // ç«¶åˆæŒ‡æ¨™
      const conflicts = await this.detectStaffConflicts(staff.uid, date, existingAssignments);
      availabilityMatrix.conflictIndicators.set(staff.uid, conflicts.length);
    }

    return availabilityMatrix;
  }

  /**
   * æœ€é©åŒ–ã‚¨ãƒ³ã‚¸ãƒ³ã®å®Ÿè¡Œ
   */
  private async runOptimizationEngine(
    constraints: ShiftConstraints,
    availability: StaffAvailabilityMatrix,
    requirements: ShiftGenerationRequirements
  ): Promise<OptimizedSlot[]> {
    console.log('ğŸ§  Running AI optimization engine...');
    
    // Step 1: æ™‚é–“ã‚¹ãƒ­ãƒƒãƒˆã®ç”Ÿæˆ
    const timeSlots = this.generateTimeSlots(constraints.businessHours, requirements.slotDuration || 120);
    
    // Step 2: å„ã‚¹ãƒ­ãƒƒãƒˆã«å¯¾ã™ã‚‹æœ€é©åŒ–
    const optimizedSlots: OptimizedSlot[] = [];
    
    for (const timeSlot of timeSlots) {
      const optimizedSlot = await this.optimizeSlot(
        timeSlot, 
        constraints, 
        availability, 
        requirements
      );
      optimizedSlots.push(optimizedSlot);
    }
    
    // Step 3: å…¨ä½“æœ€é©åŒ–ï¼ˆã‚¹ãƒ­ãƒƒãƒˆé–“ã®èª¿æ•´ï¼‰
    const globallyOptimized = await this.performGlobalOptimization(optimizedSlots, constraints);
    
    // Step 4: å“è³ªå‘ä¸Šã®ãŸã‚ã®èª¿æ•´
    const finalOptimized = await this.applyQualityEnhancements(globallyOptimized, availability);
    
    console.log(`âœ… Optimization completed: ${finalOptimized.length} slots generated`);
    return finalOptimized;
  }

  /**
   * å€‹åˆ¥ã‚¹ãƒ­ãƒƒãƒˆã®æœ€é©åŒ–
   */
  private async optimizeSlot(
    timeSlot: TimeSlotTemplate,
    constraints: ShiftConstraints,
    availability: StaffAvailabilityMatrix,
    requirements: ShiftGenerationRequirements
  ): Promise<OptimizedSlot> {
    const candidateStaff = this.findCandidateStaff(timeSlot, availability, constraints);
    
    // AI ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
    const scoredCandidates = candidateStaff.map(staff => ({
      staffId: staff.uid,
      staff,
      scores: {
        skillMatch: this.calculateSkillMatchScore(staff.skills || [], timeSlot.requiredSkills),
        availability: availability.preferenceScores.get(staff.uid) || 0,
        experience: this.calculateExperienceScore(staff),
        workload: this.calculateWorkloadScore(staff.uid, availability.date),
        cost: this.calculateCostScore(staff),
        fairness: this.calculateFairnessScore(staff.uid, availability.date)
      }
    }));
    
    // é‡ã¿ä»˜ãã‚¹ã‚³ã‚¢ã§æœ€çµ‚é¸æŠ
    const selectedStaff = this.selectOptimalStaffForSlot(
      scoredCandidates, 
      timeSlot.requiredStaff,
      requirements.optimizationStrategy || 'balanced'
    );
    
    return {
      slotId: `slot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      startTime: timeSlot.startTime,
      endTime: timeSlot.endTime,
      requiredStaff: timeSlot.requiredStaff,
      assignedStaff: selectedStaff.map(s => s.staffId),
      requiredSkills: timeSlot.requiredSkills,
      priority: timeSlot.priority,
      estimatedDuration: this.calculateDuration(timeSlot.startTime, timeSlot.endTime),
      optimizationMetrics: {
        totalScore: selectedStaff.reduce((sum, s) => sum + this.calculateTotalScore(s.scores), 0),
        skillCoverage: this.calculateSkillCoverage(selectedStaff, timeSlot.requiredSkills),
        costEfficiency: this.calculateCostEfficiency(selectedStaff),
        staffSatisfaction: this.calculateStaffSatisfaction(selectedStaff, availability)
      }
    };
  }

  /**
   * ã‚°ãƒ­ãƒ¼ãƒãƒ«æœ€é©åŒ–
   */
  private async performGlobalOptimization(
    slots: OptimizedSlot[],
    constraints: ShiftConstraints
  ): Promise<OptimizedSlot[]> {
    console.log('ğŸ”„ Performing global optimization...');
    
    // é‡è¤‡å‰²ã‚Šå½“ã¦ã®è§£æ±º
    const deduplicatedSlots = this.resolveDuplicateAssignments(slots);
    
    // åŠ´åƒæ™‚é–“ã®å‡ç­‰åŒ–
    const balancedSlots = this.balanceWorkload(deduplicatedSlots, constraints);
    
    // ã‚³ã‚¹ãƒˆæœ€é©åŒ–
    const costOptimizedSlots = this.optimizeCosts(balancedSlots, constraints);
    
    // æœ€çµ‚å“è³ªãƒã‚§ãƒƒã‚¯
    const qualityCheckedSlots = this.performQualityCheck(costOptimizedSlots, constraints);
    
    return qualityCheckedSlots;
  }

  /**
   * ã‚·ãƒ•ãƒˆã®æ§‹ç¯‰
   */
  private async constructOptimalShift(
    managerId: string,
    date: Date,
    optimizedSlots: OptimizedSlot[],
    requirements: ShiftGenerationRequirements,
    generatedBy: User
  ): Promise<ShiftExtended> {
    const shiftId = `shift_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date();

    // ã‚¹ãƒ­ãƒƒãƒˆã‚’ShiftSlotå½¢å¼ã«å¤‰æ›
    const shiftSlots: ShiftSlot[] = optimizedSlots.map(slot => ({
      slotId: slot.slotId,
      startTime: slot.startTime,
      endTime: slot.endTime,
      requiredStaff: slot.requiredStaff,
      assignedStaff: slot.assignedStaff,
      requiredSkills: slot.requiredSkills,
      priority: slot.priority,
      estimatedDuration: slot.estimatedDuration
    }));

    const generatedShift: ShiftExtended = {
      shiftId,
      managerId,
      date,
      slots: shiftSlots,
      status: 'published', // è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸã‚·ãƒ•ãƒˆã¯å³åº§ã«æœ‰åŠ¹
      createdBy: generatedBy.uid,
      createdAt: now,
      updatedAt: now,
      
      metadata: {
        totalRequiredStaff: this.calculateTotalRequiredStaff(shiftSlots),
        totalAssignedStaff: this.calculateTotalAssignedStaff(shiftSlots),
        estimatedCost: await this.estimateShiftCost(shiftSlots, managerId),
        complexity: this.determineShiftComplexity(shiftSlots),
        autogeneratedSlots: shiftSlots.length,
      },
      
      approvalWorkflow: {
        submittedBy: generatedBy.uid,
        submittedAt: now,
        lastModifiedBy: generatedBy.uid,
        modificationHistory: [{
          modifiedBy: generatedBy.uid,
          modifiedAt: now,
          changes: { status: { before: null, after: 'draft' } },
          reason: 'Auto-generated by optimization engine'
        }]
      },
      
      analytics: {
        lateChanges: 0,
        noShows: 0,
      },
      
      realTimeSync: {
        lastSyncAt: now,
        version: 1,
        conflicts: [],
      },
      
      // ç”Ÿæˆã‚¨ãƒ³ã‚¸ãƒ³å›ºæœ‰ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
      generationMetrics: {
        algorithmVersion: '3.1.0',
        optimizationStrategy: requirements.optimizationStrategy || 'balanced',
        totalOptimizationTime: 0, // å®Ÿéš›ã®å‡¦ç†æ™‚é–“ã§æ›´æ–°
        qualityScore: 0, // å¾Œã§è¨ˆç®—
        aiRecommendations: optimizedSlots.map(slot => ({
          slotId: slot.slotId,
          confidence: slot.optimizationMetrics.totalScore / 100,
          alternatives: [] // ä»£æ›¿æ¡ˆãŒã‚ã‚Œã°è¿½åŠ 
        }))
      }
    };

    return generatedShift;
  }

  /**
   * å“è³ªæ¤œè¨¼
   */
  private async validateShiftQuality(shift: ShiftExtended): Promise<number> {
    let qualityScore = 0;
    let maxScore = 0;

    // ã‚¹ã‚¿ãƒƒãƒ•ã‚£ãƒ³ã‚°ã®é©åˆ‡æ€§ (25ç‚¹)
    const staffingScore = this.evaluateStaffingQuality(shift.slots);
    qualityScore += staffingScore;
    maxScore += 25;

    // ã‚¹ã‚­ãƒ«ãƒãƒƒãƒãƒ³ã‚° (20ç‚¹)
    const skillScore = await this.evaluateSkillMatching(shift.slots);
    qualityScore += skillScore;
    maxScore += 20;

    // ã‚³ã‚¹ãƒˆåŠ¹ç‡æ€§ (20ç‚¹)
    const costScore = this.evaluateCostEfficiency(shift.metadata.estimatedCost, shift.slots.length);
    qualityScore += costScore;
    maxScore += 20;

    // å…¬å¹³æ€§ (15ç‚¹)
    const fairnessScore = await this.evaluateFairness(shift);
    qualityScore += fairnessScore;
    maxScore += 15;

    // åˆ¶ç´„éµå®ˆ (20ç‚¹)
    const constraintScore = this.evaluateConstraintCompliance(shift);
    qualityScore += constraintScore;
    maxScore += 20;

    return Math.round((qualityScore / maxScore) * 100);
  }

  /**
   * ç”Ÿæˆã•ã‚ŒãŸã‚·ãƒ•ãƒˆã®ä¿å­˜
   */
  private async saveGeneratedShift(
    shift: ShiftExtended, 
    qualityScore: number, 
    generatedBy: User
  ): Promise<ShiftExtended> {
    // å“è³ªã‚¹ã‚³ã‚¢ã‚’è¿½åŠ 
    if (shift.generationMetrics) {
      shift.generationMetrics.qualityScore = qualityScore;
    }

    try {
      const docRef = await addDoc(collection(db, 'shifts_extended'), {
        ...shift,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
        'realTimeSync.lastSyncAt': serverTimestamp(),
        'approvalWorkflow.submittedAt': serverTimestamp(),
      });

      // ç”Ÿæˆãƒ­ã‚°è¨˜éŒ²
      await logSystem(
        'Auto Shift Generated',
        generatedBy.uid,
        generatedBy.name,
        generatedBy.role,
        {
          shiftId: shift.shiftId,
          managerId: shift.managerId,
          date: shift.date.toISOString(),
          slotsGenerated: shift.slots.length,
          qualityScore,
          algorithm: shift.generationMetrics?.algorithmVersion || 'unknown'
        }
      );

      return { ...shift, id: docRef.id };
    } catch (error) {
      console.error('Error saving generated shift:', error);
      throw new Error('Failed to save generated shift');
    }
  }

  /**
   * ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ç¾¤
   */
  private generateTimeSlots(businessHours: { start: string; end: string }, duration: number): TimeSlotTemplate[] {
    // å®Ÿè£…: ãƒ“ã‚¸ãƒã‚¹æ™‚é–“ã‚’æŒ‡å®šã•ã‚ŒãŸé–“éš”ã§åˆ†å‰²
    const slots: TimeSlotTemplate[] = [];
    const startHour = parseInt(businessHours.start.split(':')[0]);
    const endHour = parseInt(businessHours.end.split(':')[0]);
    const slotDurationHours = duration / 60;
    
    for (let hour = startHour; hour < endHour; hour += slotDurationHours) {
      const nextHour = Math.min(hour + slotDurationHours, endHour);
      slots.push({
        startTime: `${hour.toString().padStart(2, '0')}:00`,
        endTime: `${nextHour.toString().padStart(2, '0')}:00`,
        requiredStaff: 2, // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
        requiredSkills: [],
        priority: 'medium'
      });
    }
    
    return slots;
  }

  private calculateDuration(startTime: string, endTime: string): number {
    return this.calculateSlotDuration(startTime, endTime);
  }

  // ãã®ä»–ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆç°¡ç•¥åŒ–ã®ãŸã‚ä¸€éƒ¨ã®ã¿å®Ÿè£…ï¼‰
  private getDayOfWeekConstraints(date: Date): any {
    return { type: 'standard', multiplier: 1 };
  }

  private async getHistoricalShiftData(managerId: string, date: Date): Promise<any> {
    return { averageStaff: 3, peakHours: ['12:00-14:00', '18:00-20:00'] };
  }

  private calculateTotalScore(scores: any): number {
    return Object.values(scores).reduce((sum: number, score) => sum + (score as number), 0) / Object.keys(scores).length;
  }

  // è¿½åŠ ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©ãŒå¿…è¦ï¼ˆtypes/index.ts ã«è¿½åŠ äºˆå®šï¼‰

  // ========== PUBLIC QUERY METHODS ==========

  /**
   * åº—èˆ—ã®ã‚·ãƒ•ãƒˆä¸€è¦§ã‚’å–å¾—
   */
  async getShiftsByShop(managerId: string, startDate?: Date, endDate?: Date): Promise<ShiftExtended[]> {
    // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚¨ãƒ©ãƒ¼ã‚’å›é¿ã™ã‚‹ãŸã‚ã€managerIdã®ã¿ã§ã‚¯ã‚¨ãƒª
    const q = query(
      collection(db, 'shifts_extended'),
      where('managerId', '==', managerId)
    );

    const snapshot = await getDocs(q);
    const allShifts = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      date: doc.data().date?.toDate() || new Date(),
      createdAt: doc.data().createdAt?.toDate() || new Date(),
      updatedAt: doc.data().updatedAt?.toDate() || new Date(),
    })) as ShiftExtended[];

    // ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§æ—¥ä»˜ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã¨ã‚½ãƒ¼ãƒˆ
    let filteredShifts = allShifts;
    
    if (startDate) {
      filteredShifts = filteredShifts.filter(shift => new Date(shift.date) >= startDate);
    }
    if (endDate) {
      filteredShifts = filteredShifts.filter(shift => new Date(shift.date) <= endDate);
    }

    // æ—¥ä»˜ã§ã‚½ãƒ¼ãƒˆ
    return filteredShifts.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
  }

  /**
   * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚·ãƒ•ãƒˆãƒªã‚¯ã‚¨ã‚¹ãƒˆä¸€è¦§ã‚’å–å¾—
   */
  async getShiftRequestsByUser(userId: string): Promise<ShiftRequestEnhanced[]> {
    const q = query(
      collection(db, 'shift_requests_enhanced'),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc')
    );

    const snapshot = await getDocs(q);
    return snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data(),
      date: doc.data().date?.toDate() || new Date(),
      createdAt: doc.data().createdAt?.toDate() || new Date(),
      updatedAt: doc.data().updatedAt?.toDate() || new Date(),
    })) as ShiftRequestEnhanced[];
  }

  // ========== STAFF SPECIFIC METHODS ==========

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ç”¨: è‡ªåˆ†ã®ã‚·ãƒ•ãƒˆã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§å–å¾—
   */
  subscribeToStaffShifts(
    staffId: string,
    callback: (shifts: ShiftExtended[]) => void
  ): () => void {
    console.log('ğŸ”„ Setting up staff shift subscription for:', staffId);

    // ã‚¹ã‚¿ãƒƒãƒ•ã¯ç™ºè¡Œæ¸ˆã¿ï¼ˆpublishedï¼‰ã‚·ãƒ•ãƒˆã®ã¿è¡¨ç¤º
    const q = query(
      collection(db, 'shifts_extended'),
      where('status', '==', 'published'),
      limit(100)
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      try {
        const allShifts = snapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data(),
          date: doc.data().date?.toDate() || new Date(),
          createdAt: doc.data().createdAt?.toDate() || new Date(),
          updatedAt: doc.data().updatedAt?.toDate() || new Date(),
        })) as ShiftExtended[];

        // ã‚¹ã‚¿ãƒƒãƒ•ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸã‚·ãƒ•ãƒˆã®ã¿ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
        const staffShifts = allShifts.filter(shift => {
          if (!shift.slots || shift.slots.length === 0) return false;

          return shift.slots.some(slot =>
            slot.assignedStaff &&
            slot.assignedStaff.includes(staffId)
          );
        });

        console.log(`ğŸ“Š Found ${staffShifts.length} shifts for staff ${staffId}`);
        callback(staffShifts.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()));
      } catch (error) {
        console.error('âŒ Error processing staff shifts:', error);
        callback([]);
      }
    }, (error) => {
      console.error('âŒ Staff shift subscription error:', error);
      callback([]);
    });

    return unsubscribe;
  }

  /**
   * ã‚¹ã‚¿ãƒƒãƒ•ç”¨: æŒ‡å®šæœŸé–“ã®ã‚·ãƒ•ãƒˆã‚’å–å¾—
   */
  async getStaffShiftsForPeriod(
    staffId: string,
    startDate: Date,
    endDate: Date
  ): Promise<ShiftExtended[]> {
    try {
      console.log(`ğŸ“… Getting staff shifts for ${staffId} from ${startDate.toISOString()} to ${endDate.toISOString()}`);

      // æœŸé–“å†…ã®ç™ºè¡Œæ¸ˆã¿ã‚·ãƒ•ãƒˆã‚’å–å¾—
      const q = query(
        collection(db, 'shifts_extended'),
        where('status', '==', 'published')
      );

      const snapshot = await getDocs(q);
      const allShifts = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
        date: doc.data().date?.toDate() || new Date(),
        createdAt: doc.data().createdAt?.toDate() || new Date(),
        updatedAt: doc.data().updatedAt?.toDate() || new Date(),
      })) as ShiftExtended[];

      // æœŸé–“ã¨ã‚¹ã‚¿ãƒƒãƒ•ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
      const staffShifts = allShifts.filter(shift => {
        const shiftDate = new Date(shift.date);
        const inPeriod = shiftDate >= startDate && shiftDate <= endDate;
        const assignedToStaff = shift.slots?.some(slot =>
          slot.assignedStaff && slot.assignedStaff.includes(staffId)
        );

        return inPeriod && assignedToStaff;
      });

      return staffShifts.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    } catch (error) {
      console.error('âŒ Error fetching staff shifts for period:', error);
      return [];
    }
  }

  /**
   * ã‚·ãƒ•ãƒˆã‚’ä¸€æ‹¬ç™ºè¡Œï¼ˆdraft â†’ publishedï¼‰
   */
  async publishShifts(shiftIds: string[]): Promise<void> {
    try {
      console.log(`ğŸ“¤ Publishing ${shiftIds.length} shifts...`);

      // å„ã‚·ãƒ•ãƒˆã®statusã‚’publishedã«æ›´æ–°
      const updatePromises = shiftIds.map(async (shiftId) => {
        const shiftRef = doc(db, 'shifts_extended', shiftId);
        await updateDoc(shiftRef, {
          status: 'published',
          updatedAt: serverTimestamp(),
          publishedAt: serverTimestamp(),
          'auditLog': {
            lastAction: 'published',
            performedBy: 'manager',
            timestamp: serverTimestamp(),
            changes: { status: { before: 'draft', after: 'published' } },
            reason: 'Manager published shift'
          }
        });
        console.log(`âœ… Published shift: ${shiftId}`);
      });

      // å…¨ã¦ã®ã‚·ãƒ•ãƒˆã‚’ä¸¦è¡Œæ›´æ–°
      await Promise.all(updatePromises);

      console.log(`ğŸ‰ Successfully published ${shiftIds.length} shifts`);
    } catch (error) {
      console.error('âŒ Error publishing shifts:', error);
      throw new Error('ã‚·ãƒ•ãƒˆã®ç™ºè¡Œã«å¤±æ•—ã—ã¾ã—ãŸã€‚å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
    }
  }
}

// Export singleton instance
export const shiftService = ShiftManagementService.getInstance();